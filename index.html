<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSI Level Parser</title>
    
    <!-- Lightning bolt favicon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3e%3cpath d='M18 2L8 16h6l-2 14 10-14h-6l2-14z' fill='%2300ff88'/%3e%3c/svg%3e">
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAdgAAAHYBTnsmCAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKASURBVFiFtZe9axRBFMafNwkWNhaChYWFhYWNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSI Level Parser</title>
    <style>
        :root {
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-light: #2a2a2a;
            --text: #ffffff;
            --text-dim: #888888;
            --accent: #00ff88;
            --accent-dim: #00cc6a;
            --border: #333333;
        }

        [data-theme="light"] {
            --bg: #f5f5f5;
            --surface: #ffffff;
            --surface-light: #f8f9fa;
            --text: #1a1a1a;
            --text-dim: #666666;
            --accent: #0066cc;
            --accent-dim: #0052a3;
            --border: #e0e0e0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .theme-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .theme-btn:hover {
            background: var(--surface-light);
        }

        .upload-area {
            background: var(--surface);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .upload-area.dragover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .file-input { display: none; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-top: 5px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .btn.primary {
            background: var(--accent);
            color: var(--bg);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: var(--surface);
            color: var(--text);
        }

        .data-table {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .table-header {
            background: var(--surface-light);
            padding: 15px 20px;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            font-family: inherit;
            font-size: 13px;
        }

        th {
            background: var(--surface-light);
            font-weight: bold;
            color: var(--text-dim);
        }

        tr:hover {
            background: var(--surface-light);
        }

        .output {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            font-family: inherit;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-bottom: 15px;
        }

        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 14px;
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .status.error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .status.warning {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid #ffa500;
            color: #ffa500;
        }

        .hidden {
            display: none;
        }

        .section { margin-bottom: 30px; }

        .type-badge {
            background: var(--surface-light);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        .type-backsight { background: rgba(0, 255, 136, 0.2); color: var(--accent); }
        .type-foresight { background: rgba(255, 165, 0, 0.2); color: #ffa500; }
        .type-intermediate { background: rgba(0, 123, 255, 0.2); color: #007bff; }

        .section-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--text);
        }

        .advanced-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px;
        }

        .advanced-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }

        .advanced-group h4 {
            margin-bottom: 15px;
            color: var(--text);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"],
        .checkbox-label input[type="radio"] {
            width: 16px;
            height: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
        }

        .help-text {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 15px;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .advanced-grid {
                grid-template-columns: 1fr;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">⚡ GSI.PARSER</div>
            <div class="header-controls">
                <button class="btn" id="aboutBtn" aria-label="About this tool">ℹ️ About</button>
                <button class="theme-btn" id="themeBtn" aria-label="Toggle theme">🌓</button>
            </div>
        </div>

        <div class="section">
            <div class="upload-area" id="uploadArea" role="button" tabindex="0">
                <div style="font-size: 36px; margin-bottom: 10px;">📁</div>
                <div>Drop GSI file here or click to select</div>
                <div style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
                    Supports .gsi, .txt, and other level data formats
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".gsi,.txt,.dat,.raw" aria-label="Select GSI file">
            </div>
            <div id="status" class="status hidden" role="alert"></div>
            <div id="formatStatus" class="status hidden" role="status"></div>
        </div>

        <!-- About Section -->
        <div class="section hidden" id="aboutSection">
            <div class="section-title">
                ℹ️ About GSI.PARSER
                <button class="btn" id="aboutToggle">Hide</button>
            </div>
            
            <div class="advanced-content">
                <div class="advanced-grid">
                    <div class="advanced-group">
                        <h4>🎯 Features</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li>Parse GSI format levelling data with intelligent format detection</li>
                            <li>Aggregate change point readings for cleaner analysis</li>
                            <li>Export to multiple formats: Reports, StarNet, CSV</li>
                            <li>Advanced processing options for different survey methods <i>coming soon!</i></li>
                            <li>Real-time data validation and error reporting <i>coming soon!</i></li>
                            <br>
                        </ul>

                        <h4>📁 Supported Formats</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>.gsi</strong> - Standard GSI format files</li>
                            <li><strong>.txt</strong> - Text-based GSI data</li>
                           
                        </ul>
                    </div>
                    
                    <div class="advanced-group">
                        <h4>⚙️ How to Use</h4>
                        <ol style="margin: 0; padding-left: 20px;">
                            <li>Upload your GSI file using drag & drop or file selection</li>
                            <li>Review the parsed data in the preview table</li>
                            <li>Configure advanced options if needed (change points, output preferences)</li>
                            <li>Export your data in the desired format</li>
                            <br>
                        </ol>

                        <h4>🔧 Technical Notes</h4>
                        <p style="margin: 0;">This parser is optimised for levelling data and supports both GSI-8 and GSI-16 formats. Processing of TPS and other forms of .GSI data are in development..</p>

                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border); font-size: 12px; color: var(--text-dim);">
                            <strong>Version:</strong> 2025.1 • <strong>Created by:</strong> B Brewster
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="statsSection">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="recordCount">0</div>
                    <div class="stat-label">Records</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="pointCount">0</div>
                    <div class="stat-label">Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="methodType">—</div>
                    <div class="stat-label">Method</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="heightRange">—</div>
                    <div class="stat-label">Height Range</div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="actionsSection">
            <div class="actions">
                <button class="btn" id="reportBtn">📄 Report</button>
                <button class="btn" id="starnetBtn">⭐ StarNet</button>
                <button class="btn" id="csvBtn">📊 CSV</button>
                <button class="btn" id="advancedBtn">⚙️ Advanced</button>
            </div>
        </div>

        <!-- Advanced Processing Section -->
        <div class="section hidden" id="advancedSection">
            <div class="section-title">
                ⚙️ Advanced Processing Options
                <button class="btn" id="advancedToggle">Hide</button>
            </div>
            
            <div class="advanced-content">
                <div class="advanced-grid">
                    <div class="advanced-group">
                        <h4>Change Point Processing</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="aggregateCP" checked>
                            <span>Aggregate change point readings</span>
                        </label>
                        <p class="help-text">
                            Groups readings between named stations through change points
                        </p>
                        
                        <label class="form-label">Change Point Detection Method:</label>
                        <div style="margin-bottom: 15px;">
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="prefix" checked>
                                <span>Text Prefix (e.g., CP, TP, TBM)</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="numeric">
                                <span>Numeric Only (1, 2, 3, 4...)</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="both">
                                <span>Both Methods</span>
                            </label>
                        </div>
                        
                        <div id="prefixSettings">
                            <label class="form-label" for="changePointPrefix">Change Point Prefix:</label>
                            <input type="text" id="changePointPrefix" value="CP" placeholder="e.g., CP, TP, TBM" class="form-input">
                        </div>
                        
                        <div id="numericSettings" style="display: none;">
                            <label class="form-label">Numeric Range:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="numericMin" value="1" min="0" max="999" class="form-input" style="width: 80px;" placeholder="Min">
                                <span>to</span>
                                <input type="number" id="numericMax" value="999" min="1" max="9999" class="form-input" style="width: 80px;" placeholder="Max">
                            </div>
                            <p class="help-text">
                                Point names that are purely numeric within this range will be treated as change points
                            </p>
                        </div>
                    </div>
                    
                    <div class="advanced-group">
                        <h4>Output Options</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="includeTurnCount">
                            <span>Include turn count in reports</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showCPDetails">
                            <span>Show change point details</span>
                        </label>
                        
                        <button class="btn primary" id="applyAdvanced" style="margin-top: 10px;">
                            <span id="applyText">Apply & Reprocess</span>
                            <div id="applySpinner" class="loading-spinner hidden" style="display: none;"></div>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="previewSection">
            <div class="data-table">
                <div class="table-header">Data Preview</div>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Point</th>
                                <th>Type</th>
                                <th>Reading</th>
                                <th>Distance</th>
                                <th>Height</th>
                                <th>Setup</th>
                            </tr>
                        </thead>
                        <tbody id="dataTable"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="section hidden" id="outputSection">
            <div class="output" id="outputArea"></div>
            <div>
                <button class="btn" id="downloadBtn">💾 Download</button>
                <button class="btn" id="copyBtn">📋 Copy</button>
            </div>
        </div>

        <!-- Footer -->
        <div style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid var(--border); color: var(--text-dim); font-size: 12px;">
            Created by B Brewster 2025
        </div>
    </div>

    <!-- Ko-fi Widget (only works on live sites) -->
    <script>
        // Ko-fi widget - will only work on a live website
        if (window.location.protocol !== 'file:' && window.location.hostname !== 'localhost') {
            const script = document.createElement('script');
            script.src = 'https://storage.ko-fi.com/cdn/scripts/overlay-widget.js';
            script.async = true;
            script.onload = function() {
                setTimeout(function() {
                    if (typeof kofiWidgetOverlay !== 'undefined') {
                        try {
                            kofiWidgetOverlay.draw('bbrewster', {
                                'type': 'floating-chat',
                                'floating-chat.donateButton.text': '',
                                'floating-chat.donateButton.background-color': '#ffffff',
                                'floating-chat.donateButton.text-color': '#323842'
                            });
                        } catch (error) {
                            console.warn('Ko-fi widget initialization failed:', error);
                        }
                    }
                }, 100);
            };
            script.onerror = function() {
                console.log('Ko-fi widget unavailable (normal for local/development sites)');
            };
            document.head.appendChild(script);
        }
    </script>

    <script>
        'use strict';

        // Security constants
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit
        const MAX_RECORDS = 500000;
        const MAX_LINE_LENGTH = 1000;
        const PROCESSING_TIMEOUT = 60000;

        class GSIParser {
            constructor() {
                this.data = [];
                this.rawData = '';
                this.stats = {};
                this.levelRuns = [];
                this.aggregatedRuns = [];
                this.processingOptions = {
                    aggregateCP: true,
                    changePointPrefix: 'CP',
                    changePointMethod: 'prefix',
                    numericMin: 1,
                    numericMax: 999,
                    includeTurnCount: false,
                    showCPDetails: false
                };
            }

            parse(text) {
                if (text.length > MAX_FILE_SIZE) {
                    throw new Error('Input text too large');
                }

                this.rawData = text;
                this.data = [];
                const lines = text.split('\n');
                
                if (lines.length > MAX_RECORDS) {
                    throw new Error(`Too many lines. Maximum ${MAX_RECORDS} lines allowed.`);
                }

                const formatAnalysis = this.analyzeGSIFormat(lines);
                this.displayFormatWarnings(formatAnalysis);
                
                let processedRecords = 0;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    if (line.length > MAX_LINE_LENGTH) {
                        console.warn(`Skipping excessively long line ${i + 1}`);
                        continue;
                    }
                    
                    if (processedRecords >= MAX_RECORDS) {
                        console.warn(`Reached maximum record limit of ${MAX_RECORDS}`);
                        break;
                    }
                    
                    const record = this.parseLine(line);
                    if (record) {
                        record.lineNumber = i + 1;
                        this.data.push(record);
                        processedRecords++;
                    }
                }
                
                this.calculateStats();
                return this.data;
            }

            analyzeGSIFormat(lines) {
                const analysis = {
                    totalLines: lines.length,
                    validGSILines: 0,
                    invalidLines: [],
                    formatType: 'unknown',
                    isTPS: false,
                    hasLevelingData: false,
                    hasCoordinateData: false,
                    wordCounts: {},
                    errors: [],
                    warnings: []
                };

                const maxSampleSize = Math.min(50, lines.length);

                for (let i = 0; i < maxSampleSize; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const lineAnalysis = this.analyzeGSILine(line, i + 1);
                    
                    if (lineAnalysis.isValid) {
                        analysis.validGSILines++;
                        
                        lineAnalysis.wordIds.forEach(wi => {
                            analysis.wordCounts[wi] = (analysis.wordCounts[wi] || 0) + 1;
                        });
                        
                        if (lineAnalysis.hasLevelingWords) analysis.hasLevelingData = true;
                        if (lineAnalysis.hasCoordinateWords) analysis.hasCoordinateData = true;
                        
                    } else {
                        analysis.invalidLines.push({
                            lineNumber: i + 1,
                            content: line.substring(0, 100) + (line.length > 100 ? '...' : ''),
                            issues: lineAnalysis.issues
                        });
                    }
                }

                this.determineGSIFormat(analysis);
                return analysis;
            }

            analyzeGSILine(line, lineNumber) {
                const result = {
                    isValid: false,
                    wordIds: [],
                    hasLevelingWords: false,
                    hasCoordinateWords: false,
                    issues: []
                };

                const words = line.split(/\s+/);
                
                if (words.length === 0) {
                    result.issues.push('Empty line');
                    return result;
                }

                let validWords = 0;
                const levelingWIs = ['331', '332', '333', '330', '83', '84', '85'];
                const coordinateWIs = ['81', '82', '83', '84', '85', '86', '87', '88'];

                for (const word of words) {
                    if (word.length < 8) {
                        result.issues.push(`Word too short: ${word}`);
                        continue;
                    }

                    let wi, isValidStructure = false;
                    
                    if (word.startsWith('*')) {
                        wi = word.substring(1, 3);
                        isValidStructure = /^\*\d{2}[\d\.]{4}[+\-]\d+$/.test(word);
                    } else {
                        if (/^\d{3}\./.test(word)) {
                            wi = word.substring(0, 3);
                            isValidStructure = /^\d{3}\.[\d\.]{2}[+\-]\d+$/.test(word);
                        } else {
                            wi = word.substring(0, 2);
                            isValidStructure = /^\d{2}[\d\.]{4}[+\-]\d+$/.test(word);
                        }
                    }

                    if (isValidStructure && !isNaN(parseInt(wi))) {
                        validWords++;
                        result.wordIds.push(wi);
                        
                        if (levelingWIs.includes(wi)) result.hasLevelingWords = true;
                        if (coordinateWIs.includes(wi)) result.hasCoordinateWords = true;
                    } else {
                        result.issues.push(`Invalid GSI word structure: ${word.substring(0, 20)}`);
                    }
                }

                result.isValid = validWords > 0;
                return result;
            }

            determineGSIFormat(analysis) {
                const tpsIndicators = ['16', '17', '18', '19', '58', '59', '71', '72', '73', '74', '75', '76'];
                const coordinateWIs = ['81', '82', '83', '84', '85', '86', '87', '88'];
                const levelingWIs = ['331', '332', '333', '330'];

                const hasTpsWords = tpsIndicators.some(wi => analysis.wordCounts[wi] > 0);
                const hasCoordinates = coordinateWIs.some(wi => analysis.wordCounts[wi] > 0);
                const hasLeveling = levelingWIs.some(wi => analysis.wordCounts[wi] > 0);

                if (hasTpsWords || (hasCoordinates && !hasLeveling)) {
                    analysis.isTPS = true;
                    analysis.formatType = 'TPS';
                    analysis.warnings.push('⚠️ TPS (Total Station) GSI detected - This parser is optimised for levelling data');
                } else if (hasLeveling) {
                    analysis.formatType = 'Levelling';
                } else if (hasCoordinates) {
                    analysis.formatType = 'Coordinate';
                    analysis.warnings.push('⚠️ Coordinate data detected - Limited support for non-levelling GSI');
                }

                const validLineRatio = analysis.validGSILines / Math.max(1, analysis.totalLines - this.countEmptyLines(analysis));
                
                if (validLineRatio < 0.7) {
                    analysis.errors.push(`❌ Poor GSI format: Only ${Math.round(validLineRatio * 100)}% of lines are valid GSI format`);
                }

                if (analysis.validGSILines === 0) {
                    analysis.errors.push('❌ No valid GSI data found - Check file format');
                }

                if (analysis.wordCounts['11'] === 0) {
                    analysis.warnings.push('⚠️ No point IDs (WI 11) found');
                }

                if (Object.keys(analysis.wordCounts).length < 3) {
                    analysis.warnings.push('⚠️ Very limited GSI word types detected');
                }
            }

            countEmptyLines(analysis) {
                return analysis.totalLines - analysis.validGSILines - analysis.invalidLines.length;
            }

            displayFormatWarnings(analysis) {
                const messages = [];

                if (analysis.formatType !== 'unknown') {
                    messages.push(`📋 GSI Format: ${analysis.formatType}`);
                }

                if (analysis.isTPS) {
                    messages.push('🔶 TPS GSI Detected: This file appears to contain Total Station data. This parser is specialised for levelling data and may not display all TPS features correctly.');
                }

                analysis.errors.forEach(error => messages.push(error));
                analysis.warnings.forEach(warning => messages.push(warning));

                if (analysis.invalidLines.length > 0) {
                    const exampleCount = Math.min(3, analysis.invalidLines.length);
                    if (analysis.invalidLines.length > exampleCount) {
                        messages.push(`... and ${analysis.invalidLines.length - exampleCount} more formatting issues`);
                    }
                }

                if (messages.length > 0) {
                    const messageText = messages.join('\n');
                    
                    let messageType = 'success';
                    if (analysis.errors.length > 0) {
                        messageType = 'error';
                    } else if (analysis.warnings.length > 0 || analysis.isTPS) {
                        messageType = 'warning';
                    }
                    
                    this.showFormatStatus(messageText, messageType);
                }
            }

            showFormatStatus(message, type) {
                let formatStatus = document.getElementById('formatStatus');
                if (!formatStatus) {
                    formatStatus = document.createElement('div');
                    formatStatus.id = 'formatStatus';
                    formatStatus.className = 'status';
                    
                    const mainStatus = document.getElementById('status');
                    mainStatus.parentNode.insertBefore(formatStatus, mainStatus.nextSibling);
                }
                
                formatStatus.textContent = message;
                formatStatus.className = 'status ' + type;
                formatStatus.classList.remove('hidden');
                formatStatus.style.whiteSpace = 'pre-line';
                formatStatus.style.marginTop = '10px';
                formatStatus.style.fontSize = '13px';
            }

            reprocess() {
                if (!this.rawData) return;
                return this.parse(this.rawData);
            }

            updateProcessingOptions(options) {
                this.processingOptions = { ...this.processingOptions, ...options };
                const result = this.reprocess();
                this.aggregatedRuns = this.aggregateChangePointRuns();
                return result;
            }

            parseLine(line) {
                const words = line.split(/\s+/);
                const record = { words: {}, type: 'unknown' };
                
                for (const word of words) {
                    const parsed = this.parseWord(word);
                    if (parsed) {
                        record.words[parsed.wi] = parsed;
                    }
                }
                
                if (record.words['331']) record.type = 'backsight';
                else if (record.words['332']) record.type = 'foresight';
                else if (record.words['333']) record.type = 'intermediate';
                else if (record.words['330']) record.type = 'measure_only';
                
                return Object.keys(record.words).length > 0 ? record : null;
            }

            parseWord(word) {
                if (word.length < 8 || word.length > 100) return null;
                
                let wi, info, sign, data;
                
                if (word.startsWith('*')) {
                    wi = word.substring(1, 3);
                    info = word.substring(3, 7);
                    sign = word.substring(7, 8);
                    data = word.substring(8);
                } else {
                    const first3 = word.substring(0, 3);
                    const fourth = word.substring(3, 4);
                    
                    if (!isNaN(first3) && fourth === '.' && first3.length === 3 && 
                        parseInt(first3) >= 330 && parseInt(first3) <= 399) {
                        wi = first3;
                        info = word.substring(3, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    } else {
                        wi = word.substring(0, 2);
                        info = word.substring(2, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    }
                }
                
                if (wi && isNaN(parseInt(wi))) {
                    console.warn('Non-numeric WI detected:', wi, 'in word:', word.substring(0, 20));
                    return null;
                }
                
                const value = this.interpretValue(wi, sign + data, info);
                return { wi, info, sign, data, value };
            }

            interpretValue(wi, valueStr, info) {
                if (wi === '11') {
                    let cleaned = valueStr.replace(/^[+\-0]*/, '');
                    cleaned = cleaned.replace(/^0+/, '') || valueStr;
                    
                    if (!cleaned || cleaned.length === 0) {
                        cleaned = valueStr;
                    }
                    
                    return cleaned;
                }
                
                const num = parseInt(valueStr);
                if (isNaN(num)) {
                    console.warn('Non-numeric value for WI', wi, ':', valueStr);
                    return 0;
                }
                
                const pos6 = info.charAt(info.length - 1);
                let scale = 1000;
                if (pos6 === '6') scale = 10000;
                else if (pos6 === '8') scale = 100000;
                
                if (['390', '391', '392'].includes(wi)) return num;
                
                return num / scale;
            }

            calculateStats() {
                const points = new Set();
                const heights = [];
                let setupCount = 0;
                
                this.levelRuns = this.buildLevelRuns();
                this.aggregatedRuns = this.aggregateChangePointRuns();
                
                this.data.forEach(record => {
                    if (record.words['11']) {
                        points.add(record.words['11'].value);
                    }
                    if (record.words['83']) {
                        heights.push(record.words['83'].value);
                    }
                    if (record.type === 'backsight') {
                        setupCount++;
                    }
                });
                
                this.stats = {
                    recordCount: this.data.length,
                    pointCount: points.size,
                    setupCount: setupCount,
                    uniquePoints: Array.from(points),
                    heightRange: heights.length > 0 ? 
                        `${Math.min(...heights).toFixed(3)}m - ${Math.max(...heights).toFixed(3)}m` : '—',
                    method: this.detectMethod()
                };
                
                // Check for calibration/2-peg test data
                this.calibrationInfo = this.identifyCalibrationData();
                if (this.calibrationInfo.isCalibration) {
                    this.displayCalibrationWarning(this.calibrationInfo);
                }
            }

            detectMethod() {
                const methodRecord = this.data.find(r => r.words['41'] && r.words['41'].data.includes('?'));
                if (methodRecord) {
                    const code = methodRecord.words['41'].data;
                    if (code.includes('1')) return 'BF';
                    else if (code.includes('2')) return 'BFFB';
                    else return 'Unknown';
                }
                return '—';
            }

            identifyCalibrationData() {
                const result = { isCalibration: false, type: null, confidence: 0, issues: [] };
                
                // Check for 2-peg test at start of file (first 10 records)
                const earlyRecords = this.data.slice(0, 10);
                const early2PegCheck = this.checkEarly2PegPattern(earlyRecords);
                if (early2PegCheck.is2Peg) {
                    result.isCalibration = true;
                    result.type = '2-peg-test';
                    result.confidence = early2PegCheck.confidence;
                    result.issues = early2PegCheck.issues;
                    result.recordRange = early2PegCheck.recordRange;
                    return result;
                }
                
                // Original logic for small data sets
                if (this.levelRuns.length > 5 || this.stats.pointCount > 8) {
                    return result;
                }
                
                const points = this.stats.uniquePoints;
                let confidenceScore = 0;
                const maxConfidence = 100;
                
                // 1. Check point naming patterns (30 points)
                const calibrationNames = points.filter(point => 
                    /^(PEG|PG|A|B|TEST|CAL|CALIB|CALIBR|2PEG|TWOPEG|TP1|TP2)$/i.test(point) ||
                    /^[AB][12]?$/i.test(point) || // A, B, A1, A2, B1, B2
                    /^(POINT|PT)[AB12]?$/i.test(point) // POINTA, POINTB, PT1, PT2
                );
                
                if (calibrationNames.length >= 2) {
                    confidenceScore += 30;
                    result.issues.push(`Calibration-style point names detected: ${calibrationNames.join(', ')}`);
                }
                
                // 2. Check for typical 2-peg pattern: 2 points, 2-3 setups (25 points)
                if (points.length === 2 && this.levelRuns.length >= 2 && this.levelRuns.length <= 3) {
                    confidenceScore += 25;
                    result.issues.push('Classic 2-peg test pattern: 2 points with 2-3 setups');
                }
                
                // 3. Check for repeated point observations (20 points)
                const repeatedPattern = this.checkRepeatedPointPattern();
                if (repeatedPattern.hasRepeated) {
                    confidenceScore += 20;
                    result.issues.push(`Points observed multiple times: ${repeatedPattern.repeatedPoints.join(', ')}`);
                }
                
                // 4. Check distance patterns if coordinate data available (15 points)
                const distanceCheck = this.checkDistancePattern();
                if (distanceCheck.isTypical2PegDistance) {
                    confidenceScore += 15;
                    result.issues.push(`Distance pattern consistent with 2-peg test: ~${distanceCheck.distance.toFixed(0)}m`);
                }
                
                // 5. Check for limited data set (10 points)
                if (this.stats.recordCount <= 10 && this.stats.pointCount <= 4) {
                    confidenceScore += 10;
                    result.issues.push('Very limited data set typical of calibration test');
                }
                
                // Determine if this is likely calibration data
                if (confidenceScore >= 40) {
                    result.isCalibration = true;
                    result.type = confidenceScore >= 60 ? '2-peg-test' : 'possible-calibration';
                    result.confidence = Math.min(confidenceScore, maxConfidence);
                }
                
                return result;
            }

            checkEarly2PegPattern(earlyRecords) {
                const result = { is2Peg: false, confidence: 0, issues: [], recordRange: null };
                
                // Look for A1, A2, B1, B2 pattern in first 10 records
                const pointPattern = [];
                const recordNumbers = [];
                
                earlyRecords.forEach((record, index) => {
                    const pointName = record.words['11']?.value;
                    if (pointName && /^[AB][12]$/i.test(pointName)) {
                        pointPattern.push(pointName.toUpperCase());
                        recordNumbers.push(index + 1);
                    }
                });
                
                // Check for classic 2-peg sequence patterns
                const patternStr = pointPattern.join('-');
                const classic2PegPatterns = [
                    'A1-B1-B2-A2',  // Most common
                    'A1-B1-A2-B2',  // Alternative 
                    'B1-A1-A2-B2',  // Reversed start
                    'B1-A1-B2-A2'   // Alternative reversed
                ];
                
                if (classic2PegPatterns.includes(patternStr)) {
                    result.is2Peg = true;
                    result.confidence = 95;
                    result.recordRange = `Records ${recordNumbers[0]}-${recordNumbers[recordNumbers.length - 1]}`;
                    result.issues.push(`Classic 2-peg test sequence detected: ${patternStr}`);
                    result.issues.push(`Found at start of file in ${result.recordRange}`);
                    result.issues.push('This calibration data may affect survey calculations if included');
                    return result;
                }
                
                // Check for simpler A-B pattern at start
                if (pointPattern.length >= 2) {
                    const hasAB = pointPattern.some(p => p.startsWith('A')) && 
                                 pointPattern.some(p => p.startsWith('B'));
                    if (hasAB && recordNumbers[recordNumbers.length - 1] <= 6) {
                        result.is2Peg = true;
                        result.confidence = 75;
                        result.recordRange = `Records ${recordNumbers[0]}-${recordNumbers[recordNumbers.length - 1]}`;
                        result.issues.push(`2-peg test pattern detected: ${patternStr}`);
                        result.issues.push(`Found at start of file in ${result.recordRange}`);
                        result.issues.push('Early A/B point sequence suggests calibration test');
                    }
                }
                
                return result;
            }

            checkRepeatedPointPattern() {
                const pointObservations = {};
                const result = { hasRepeated: false, repeatedPoints: [] };
                
                // Count how many times each point appears
                this.levelRuns.forEach(run => {
                    const bsPoint = run.backsight.words['11']?.value;
                    if (bsPoint) {
                        pointObservations[bsPoint] = (pointObservations[bsPoint] || 0) + 1;
                    }
                    
                    run.foresights.forEach(fs => {
                        const fsPoint = fs.words['11']?.value;
                        if (fsPoint) {
                            pointObservations[fsPoint] = (pointObservations[fsPoint] || 0) + 1;
                        }
                    });
                });
                
                // Find points observed more than twice (typical in 2-peg tests)
                Object.entries(pointObservations).forEach(([point, count]) => {
                    if (count > 2) {
                        result.hasRepeated = true;
                        result.repeatedPoints.push(`${point}(${count}x)`);
                    }
                });
                
                return result;
            }

            checkDistancePattern() {
                const result = { isTypical2PegDistance: false, distance: 0 };
                
                // Try to calculate distance between points using coordinate data
                const coordinatePoints = this.data.filter(record => 
                    record.words['11'] && record.words['81'] && record.words['82']
                ).map(record => ({
                    name: record.words['11'].value,
                    x: record.words['81'].value,
                    y: record.words['82'].value
                }));
                
                if (coordinatePoints.length >= 2) {
                    // Calculate distance between first two coordinate points
                    const p1 = coordinatePoints[0];
                    const p2 = coordinatePoints[1];
                    const distance = Math.sqrt(
                        Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)
                    );
                    
                    result.distance = distance;
                    
                    // Check if distance is typical for 2-peg test (40-80m)
                    if (distance >= 40 && distance <= 80) {
                        result.isTypical2PegDistance = true;
                    }
                }
                
                return result;
            }

            displayCalibrationWarning(calibrationInfo) {
                const messages = [];
                
                messages.push(`🔶 ${calibrationInfo.type.toUpperCase()} DETECTED (${calibrationInfo.confidence}% confidence)`);
                messages.push('');
                
                if (calibrationInfo.recordRange) {
                    messages.push(`📍 Location: ${calibrationInfo.recordRange}`);
                    messages.push('');
                }
                
                messages.push('This data appears to be calibration/testing rather than survey measurements:');
                
                calibrationInfo.issues.forEach(issue => {
                    messages.push(`• ${issue}`);
                });
                
                messages.push('');
                messages.push('⚠️ RECOMMENDATIONS:');
                if (calibrationInfo.recordRange) {
                    messages.push('• Consider excluding these initial records from survey calculations');
                    messages.push('• Process the remaining survey data separately');
                } else {
                    messages.push('• Consider excluding this data from survey calculations');
                    messages.push('• Separate calibration data from main survey data');
                }
                messages.push('• Review if this file should be processed differently');
                messages.push('• Check instrument calibration documentation');
                
                const messageText = messages.join('\n');
                this.showFormatStatus(messageText, 'warning');
            }

            buildLevelRuns() {
                const runs = [];
                let currentRun = null;
                let setupNumber = 0;
                
                this.data.forEach((record, index) => {
                    if (record.type === 'backsight') {
                        if (currentRun) {
                            runs.push(currentRun);
                        }
                        setupNumber++;
                        currentRun = {
                            setupNumber: setupNumber,
                            backsight: record,
                            foresights: [],
                            intermediates: []
                        };
                        record.setupNumber = setupNumber;
                    } else if (currentRun) {
                        record.setupNumber = setupNumber;
                        if (record.type === 'foresight') {
                            currentRun.foresights.push(record);
                        } else if (record.type === 'intermediate') {
                            currentRun.intermediates.push(record);
                        }
                    }
                });
                
                if (currentRun) {
                    runs.push(currentRun);
                }
                
                return runs;
            }

            isChangePoint(pointId) {
                if (!pointId) return false;
                
                const method = this.processingOptions.changePointMethod;
                const prefix = this.processingOptions.changePointPrefix.toUpperCase();
                const upperPointId = pointId.toUpperCase();
                
                switch (method) {
                    case 'prefix':
                        return upperPointId.startsWith(prefix);
                        
                    case 'numeric':
                        if (!/^\d+$/.test(pointId)) return false;
                        const num = parseInt(pointId);
                        return num >= this.processingOptions.numericMin && 
                               num <= this.processingOptions.numericMax;
                        
                    case 'both':
                        if (upperPointId.startsWith(prefix)) return true;
                        
                        if (!/^\d+$/.test(pointId)) return false;
                        const numBoth = parseInt(pointId);
                        return numBoth >= this.processingOptions.numericMin && 
                               numBoth <= this.processingOptions.numericMax;
                        
                    default:
                        return false;
                }
            }

            aggregateChangePointRuns() {
                if (!this.processingOptions.aggregateCP) {
                    return this.levelRuns;
                }

                const aggregatedRuns = [];
                const prefix = this.processingOptions.changePointPrefix.toUpperCase();
                
                const maxIterations = this.levelRuns.length * 2;
                let iterations = 0;
                
                let i = 0;
                while (i < this.levelRuns.length && iterations < maxIterations) {
                    iterations++;
                    
                    const currentRun = this.levelRuns[i];
                    
                    const bsPoint = currentRun.backsight.words['11'] ? 
                        currentRun.backsight.words['11'].value.toUpperCase() : '';
                    const isStartOfSequence = !this.isChangePoint(bsPoint) && 
                        currentRun.foresights.some(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            return this.isChangePoint(fsPoint);
                        });
                    
                    if (!isStartOfSequence) {
                        aggregatedRuns.push(currentRun);
                        i++;
                        continue;
                    }
                    
                    let sequenceRuns = [currentRun];
                    let j = i + 1;
                    
                    while (j < this.levelRuns.length && iterations < maxIterations) {
                        iterations++;
                        const nextRun = this.levelRuns[j];
                        const nextBsPoint = nextRun.backsight.words['11'] ? 
                            nextRun.backsight.words['11'].value : '';
                        
                        if (this.isChangePoint(nextBsPoint)) {
                            sequenceRuns.push(nextRun);
                            j++;
                        } else {
                            break;
                        }
                    }
                    
                    const firstRun = sequenceRuns[0];
                    const lastRun = sequenceRuns[sequenceRuns.length - 1];
                    
                    const finalForesight = lastRun.foresights.find(fs => {
                        const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                        return !this.isChangePoint(fsPoint);
                    });
                    
                    if (finalForesight) {
                        let totalDistance = 0;
                        let totalHeightDiff = 0;
                        let changePointCount = 0;
                        
                        sequenceRuns.forEach(run => {
                            const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                            const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                            totalDistance += bsDistance;
                            
                            run.foresights.forEach(fs => {
                                const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                                const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                                const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                                
                                totalDistance += fsDistance;
                                totalHeightDiff += (bsReading - fsReading);
                                
                                if (this.isChangePoint(fsPoint)) {
                                    changePointCount++;
                                }
                            });
                        });
                        
                        const aggregatedRun = {
                            setupNumber: firstRun.setupNumber,
                            backsight: firstRun.backsight,
                            foresights: [finalForesight],
                            intermediates: [],
                            totalTurns: changePointCount + 1,
                            totalDistance: totalDistance,
                            totalHeightDiff: totalHeightDiff,
                            isAggregated: true,
                            changePoints: sequenceRuns.slice(0, -1).map(run => run.foresights).flat()
                                .filter(fs => this.isChangePoint(fs.words['11'] ? fs.words['11'].value : ''))
                        };
                        
                        aggregatedRuns.push(aggregatedRun);
                    } else {
                        sequenceRuns.forEach(run => aggregatedRuns.push(run));
                    }
                    
                    i = j;
                }

                if (iterations >= maxIterations) {
                    console.warn('Aggregation loop safety limit reached');
                }

                return aggregatedRuns;
            }

            generateReport() {
                let report = 'LEVELLING REPORT\n';
                report += '================\n\n';
                report += `Generated: ${new Date().toLocaleString()}\n`;
                report += `Records: ${this.stats.recordCount}\n`;
                report += `Points: ${this.stats.pointCount}\n`;
                report += `Setups: ${this.stats.setupCount}\n`;
                report += `Method: ${this.stats.method}\n`;
                report += `Height Range: ${this.stats.heightRange}\n`;
                
                if (this.processingOptions.aggregateCP) {
                    let cpInfo = 'Change Point Processing: Enabled (';
                    if (this.processingOptions.changePointMethod === 'prefix') {
                        cpInfo += `Prefix: ${this.processingOptions.changePointPrefix}`;
                    } else if (this.processingOptions.changePointMethod === 'numeric') {
                        cpInfo += `Numeric: ${this.processingOptions.numericMin}-${this.processingOptions.numericMax}`;
                    } else {
                        cpInfo += `Both: ${this.processingOptions.changePointPrefix} and ${this.processingOptions.numericMin}-${this.processingOptions.numericMax}`;
                    }
                    cpInfo += ')\n';
                    report += cpInfo;
                }
                
                report += '\n';
                report += 'POINT          TYPE          READING       DISTANCE      HEIGHT        SETUP\n';
                report += '-----------------------------------------------------------------------\n';
                
                this.data.forEach(record => {
                    const point = record.words['11'] ? record.words['11'].value : '';
                    const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                    const height = record.words['83'] ? record.words['83'].value.toFixed(4) : '';
                    const setup = record.setupNumber || '';
                    
                    let reading = '';
                    ['330', '331', '332', '333'].forEach(wi => {
                        if (record.words[wi]) reading = record.words[wi].value.toFixed(5);
                    });
                    
                    if (point || reading || distance || height) {
                        report += point.padEnd(14) + ' ';
                        report += record.type.padEnd(13) + ' ';
                        report += reading.padStart(13) + ' ';
                        report += distance.padStart(13) + ' ';
                        report += height.padStart(13) + ' ';
                        report += setup.toString().padStart(5) + '\n';
                    }
                });
                
                if (this.levelRuns && this.levelRuns.length > 0) {
                    report += '\nLEVEL RUN SUMMARY\n';
                    report += '==================\n\n';
                    
                    const runsToShow = this.processingOptions.aggregateCP ? this.aggregatedRuns : this.levelRuns;
                    
                    runsToShow.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value.toFixed(5) : '';
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value.toFixed(3) : '';
                        
                        report += `Setup ${run.setupNumber}:\n`;
                        report += `  BS: ${bsPoint} (${bsReading}m @ ${bsDistance}m)\n`;
                        
                        if (this.processingOptions.showCPDetails && run.changePoints && run.changePoints.length > 0) {
                            run.changePoints.forEach(cp => {
                                const cpPoint = cp.words['11'] ? cp.words['11'].value : '';
                                const cpReading = cp.words['332'] ? cp.words['332'].value.toFixed(5) : '';
                                const cpDistance = cp.words['32'] ? cp.words['32'].value.toFixed(3) : '';
                                report += `  CP: ${cpPoint} (${cpReading}m @ ${cpDistance}m)\n`;
                            });
                        }
                        
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value.toFixed(5) : '';
                            const fsDistance = fs.words['32'] ? fs.words['32'].value.toFixed(3) : '';
                            const heightDiff = run.backsight.words['331'] && fs.words['332'] ? 
                                (run.backsight.words['331'].value - fs.words['332'].value).toFixed(5) : '';
                            
                            let fsLine = `  FS: ${fsPoint} (${fsReading}m @ ${fsDistance}m) Δh=${heightDiff}m`;
                            
                            if (this.processingOptions.includeTurnCount && run.isAggregated && run.totalTurns > 1) {
                                fsLine += ` [${run.totalTurns} turns]`;
                            }
                            
                            report += fsLine + '\n';
                        });
                        
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isReading = is.words['333'] ? is.words['333'].value.toFixed(5) : '';
                            const isDistance = is.words['32'] ? is.words['32'].value.toFixed(3) : '';
                            
                            report += `  IS: ${isPoint} (${isReading}m @ ${isDistance}m)\n`;
                        });
                        
                        report += '\n';
                    });
                }
                
                return report;
            }

            exportStarNet() {
                let output = '# GSI Level Data Export\n';
                output += `# Generated: ${new Date().toLocaleString()}\n`;
                output += `# Method: ${this.stats.method}\n`;
                output += `# Setups: ${this.stats.setupCount}\n\n`;
                
                output += '.UNITS METERS\n';
                output += '#.SEPARATOR /\n\n';
                
                const firstPoint = this.data.find(r => r.words['11'] && r.words['83']);
                if (firstPoint) {
                    output += '# Fixed elevation - uncomment if needed:\n';
                    output += `#E ${firstPoint.words['11'].value} ${firstPoint.words['83'].value.toFixed(4)}\n\n`;
                }
                
                const runsToProcess = (this.processingOptions.aggregateCP && this.aggregatedRuns) ? 
                    this.aggregatedRuns : this.levelRuns;
                
                if (runsToProcess && runsToProcess.length > 0) {
                    runsToProcess.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                        
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                            const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                            
                            if (bsPoint && fsPoint) {
                                let heightDiff, totalDistance;
                                
                                if (run.isAggregated) {
                                    heightDiff = run.totalHeightDiff;
                                    totalDistance = run.totalDistance;
                                } else {
                                    heightDiff = bsReading - fsReading;
                                    totalDistance = bsDistance + fsDistance;
                                }
                                
                                let comment = `# Setup ${run.setupNumber}: `;
                                
                                if (run.isAggregated && run.totalTurns > 1) {
                                    comment += `Aggregated ${run.totalTurns} turns, Total distance=${totalDistance.toFixed(3)}m`;
                                } else {
                                    comment += `BS=${bsDistance.toFixed(3)}m, FS=${fsDistance.toFixed(3)}m`;
                                }
                                
                                output += comment + '\n';
                                output += `L ${bsPoint}-${fsPoint} ${heightDiff.toFixed(5)} ${totalDistance.toFixed(3)}\n`;
                            }
                        });
                        
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isHeight = is.words['83'] ? is.words['83'].value : null;
                            
                            if (isPoint && isHeight !== null) {
                                output += '# Intermediate sight - uncomment if needed:\n';
                                output += `#E ${isPoint} ${isHeight.toFixed(4)}\n`;
                            }
                        });
                        
                        output += '\n';
                    });
                } else {
                    let lastPoint = null;
                    let lastHeight = null;
                    let lastDistance = 0;
                    
                    this.data.forEach(record => {
                        if (record.words['11'] && record.words['83']) {
                            const point = record.words['11'].value;
                            const height = record.words['83'].value;
                            const distance = record.words['32'] ? record.words['32'].value : 0;
                            
                            if (lastPoint && lastHeight !== null) {
                                const heightDiff = height - lastHeight;
                                const totalDist = lastDistance + distance;
                                
                                output += `L ${lastPoint}-${point} ${heightDiff.toFixed(5)} ${totalDist.toFixed(3)}\n`;
                            }
                            
                            if (record.type === 'foresight') {
                                lastPoint = point;
                                lastHeight = height;
                                lastDistance = distance;
                            }
                        }
                    });
                }
                
                output += '\n# End of level data\n';
                return output;
            }

            exportCSV() {
                let csv = 'Point,Type,Reading,Distance,Height,Setup,Line\n';
                
                this.data.forEach(record => {
                    const point = record.words['11'] ? record.words['11'].value : '';
                    const distance = record.words['32'] ? record.words['32'].value : '';
                    const height = record.words['83'] ? record.words['83'].value : '';
                    const setup = record.setupNumber || '';
                    
                    let reading = '';
                    ['330', '331', '332', '333'].forEach(wi => {
                        if (record.words[wi]) reading = record.words[wi].value;
                    });
                    
                    csv += `"${point}","${record.type}","${reading}","${distance}","${height}","${setup}","${record.lineNumber}"\n`;
                });
                
                return csv;
            }
        }

        // App state
        let parser = new GSIParser();
        let currentOutput = '';
        let currentExtension = 'txt';

        // DOM elements
        const elements = {
            themeBtn: document.getElementById('themeBtn'),
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            status: document.getElementById('status'),
            statsSection: document.getElementById('statsSection'),
            actionsSection: document.getElementById('actionsSection'),
            previewSection: document.getElementById('previewSection'),
            outputSection: document.getElementById('outputSection'),
            dataTable: document.getElementById('dataTable'),
            outputArea: document.getElementById('outputArea'),
            recordCount: document.getElementById('recordCount'),
            pointCount: document.getElementById('pointCount'),
            methodType: document.getElementById('methodType'),
            heightRange: document.getElementById('heightRange'),
            reportBtn: document.getElementById('reportBtn'),
            starnetBtn: document.getElementById('starnetBtn'),
            csvBtn: document.getElementById('csvBtn'),
            advancedBtn: document.getElementById('advancedBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            copyBtn: document.getElementById('copyBtn'),
            advancedSection: document.getElementById('advancedSection'),
            advancedToggle: document.getElementById('advancedToggle'),
            applyAdvanced: document.getElementById('applyAdvanced'),
            aggregateCP: document.getElementById('aggregateCP'),
            changePointPrefix: document.getElementById('changePointPrefix'),
            includeTurnCount: document.getElementById('includeTurnCount'),
            showCPDetails: document.getElementById('showCPDetails'),
            prefixSettings: document.getElementById('prefixSettings'),
            numericSettings: document.getElementById('numericSettings'),
            numericMin: document.getElementById('numericMin'),
            numericMax: document.getElementById('numericMax'),
            applyText: document.getElementById('applyText'),
            applySpinner: document.getElementById('applySpinner'),
            aboutBtn: document.getElementById('aboutBtn'),
            aboutSection: document.getElementById('aboutSection'),
            aboutToggle: document.getElementById('aboutToggle')
        };

        // Initialize app
        function initializeApp() {
            setupEventListeners();
            loadSavedTheme();
        }

        function setupEventListeners() {
            // Theme toggle
            elements.themeBtn.addEventListener('click', toggleTheme);

            // File upload
            elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
            elements.uploadArea.addEventListener('dragover', handleDragOver);
            elements.uploadArea.addEventListener('dragleave', handleDragLeave);
            elements.uploadArea.addEventListener('drop', handleDrop);
            elements.fileInput.addEventListener('change', handleFileSelect);

            // Advanced options
            elements.advancedBtn.addEventListener('click', toggleAdvancedSection);
            elements.advancedToggle.addEventListener('click', hideAdvancedSection);

            // About section
            elements.aboutBtn.addEventListener('click', toggleAboutSection);
            elements.aboutToggle.addEventListener('click', hideAboutSection);

            // Change point method toggle
            document.querySelectorAll('input[name="changePointMethod"]').forEach(radio => {
                radio.addEventListener('change', (e) => toggleChangePointSettings(e.target.value));
            });

            // Apply advanced settings
            elements.applyAdvanced.addEventListener('click', applyAdvancedSettings);

            // Export buttons with highlighting
            elements.reportBtn.addEventListener('click', () => {
                setActiveExportButton('reportBtn');
                showOutput(parser.generateReport());
            });
            elements.starnetBtn.addEventListener('click', () => {
                setActiveExportButton('starnetBtn');
                showOutput(parser.exportStarNet());
            });
            elements.csvBtn.addEventListener('click', () => {
                setActiveExportButton('csvBtn');
                showOutput(parser.exportCSV());
            });

            // Output actions
            elements.downloadBtn.addEventListener('click', downloadOutput);
            elements.copyBtn.addEventListener('click', copyOutput);

            // Keyboard accessibility
            elements.uploadArea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    elements.fileInput.click();
                }
            });
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            const newTheme = current === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            try {
                localStorage.setItem('theme', newTheme);
            } catch (e) {
                console.warn('Could not save theme preference');
            }
        }

        function loadSavedTheme() {
            try {
                const savedTheme = localStorage.getItem('theme') || 'dark';
                document.documentElement.setAttribute('data-theme', savedTheme);
            } catch (e) {
                console.warn('Could not load theme preference');
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            elements.uploadArea.classList.add('dragover');
        }

        function handleDragLeave(e) {
            elements.uploadArea.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        }

        function toggleAdvancedSection() {
            elements.advancedSection.classList.toggle('hidden');
            elements.advancedBtn.textContent = elements.advancedSection.classList.contains('hidden') ? 
                '⚙️ Advanced' : '⚙️ Hide Advanced';
        }

        function hideAdvancedSection() {
            elements.advancedSection.classList.add('hidden');
            elements.advancedBtn.textContent = '⚙️ Advanced';
        }

        function toggleAboutSection() {
            elements.aboutSection.classList.toggle('hidden');
            elements.aboutBtn.textContent = elements.aboutSection.classList.contains('hidden') ? 
                'ℹ️ About' : 'ℹ️ Hide About';
        }

        function hideAboutSection() {
            elements.aboutSection.classList.add('hidden');
            elements.aboutBtn.textContent = 'ℹ️ About';
        }

        function setActiveExportButton(activeButtonId) {
            // Remove primary class from all export buttons
            const exportButtons = ['reportBtn', 'starnetBtn', 'csvBtn'];
            exportButtons.forEach(btnId => {
                elements[btnId].classList.remove('primary');
            });
            
            // Add primary class to the active button
            elements[activeButtonId].classList.add('primary');
        }

        function toggleChangePointSettings(method) {
            switch (method) {
                case 'prefix':
                    elements.prefixSettings.style.display = 'block';
                    elements.numericSettings.style.display = 'none';
                    break;
                case 'numeric':
                    elements.prefixSettings.style.display = 'none';
                    elements.numericSettings.style.display = 'block';
                    break;
                case 'both':
                    elements.prefixSettings.style.display = 'block';
                    elements.numericSettings.style.display = 'block';
                    break;
            }
        }

        async function applyAdvancedSettings() {
            const button = elements.applyAdvanced;
            const originalText = elements.applyText.textContent;
            
            // Show loading state
            button.disabled = true;
            elements.applyText.style.display = 'none';
            elements.applySpinner.classList.remove('hidden');
            elements.applySpinner.style.display = 'inline-block';
            
            try {
                const changePointMethod = document.querySelector('input[name="changePointMethod"]:checked').value;
                
                const newOptions = {
                    aggregateCP: elements.aggregateCP.checked,
                    changePointPrefix: elements.changePointPrefix.value || 'CP',
                    changePointMethod: changePointMethod,
                    numericMin: parseInt(elements.numericMin.value) || 1,
                    numericMax: parseInt(elements.numericMax.value) || 999,
                    includeTurnCount: elements.includeTurnCount.checked,
                    showCPDetails: elements.showCPDetails.checked
                };
                
                // Simulate processing delay for UX
                await new Promise(resolve => setTimeout(resolve, 500));
                
                parser.updateProcessingOptions(newOptions);
                showStatus('✓ Data reprocessed with new options', 'success');
                updateUI();
                
                elements.outputSection.classList.add('hidden');
                
                // Reset button state first - HIDE SPINNER COMPLETELY
                button.disabled = false;
                elements.applySpinner.classList.add('hidden');
                elements.applySpinner.style.display = 'none';
                
                // Show success state
                elements.applyText.textContent = '✓ Applied';
                elements.applyText.style.display = 'inline';
                button.style.background = 'var(--accent)';
                button.style.color = 'var(--bg)';
                
                setTimeout(() => {
                    elements.applyText.textContent = originalText;
                    button.style.background = '';
                    button.style.color = '';
                }, 2000);
                
            } catch (error) {
                console.error('Reprocessing error:', error);
                showStatus('✗ Error reprocessing: ' + error.message, 'error');
                
                // Reset button state on error
                button.disabled = false;
                elements.applyText.style.display = 'inline';
                elements.applySpinner.classList.add('hidden');
                elements.applySpinner.style.display = 'none';
            }
        }

        function processFile(file) {
            if (file.size > MAX_FILE_SIZE) {
                showStatus('✗ File too large. Maximum size is 50MB.', 'error');
                return;
            }

            const allowedExtensions = ['.gsi', '.txt', '.dat', '.raw'];
            const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
            if (!allowedExtensions.includes(fileExtension)) {
                showStatus('✗ Invalid file type. Only GSI, TXT, DAT, and RAW files are allowed.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const timeoutId = setTimeout(() => {
                        throw new Error('File processing timeout - file may be malformed');
                    }, PROCESSING_TIMEOUT);

                    const result = parser.parse(e.target.result);
                    clearTimeout(timeoutId);
                    
                    showStatus(`✓ Parsed ${parser.data.length} records`, 'success');
                    updateUI();
                } catch (error) {
                    showStatus(`✗ Error: ${escapeHtml(error.message)}`, 'error');
                    console.error('Parsing error:', error);
                }
            };
            
            reader.onerror = function() {
                showStatus('✗ Error reading file', 'error');
            };
            
            reader.readAsText(file);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showStatus(message, type) {
            elements.status.textContent = message;
            elements.status.className = 'status ' + type;
            elements.status.classList.remove('hidden');
        }

        function updateUI() {
            // Update stats
            elements.recordCount.textContent = parser.stats.recordCount;
            elements.pointCount.textContent = parser.stats.pointCount;
            elements.methodType.textContent = parser.stats.method;
            elements.heightRange.textContent = parser.stats.heightRange;

            // Update table with XSS protection
            elements.dataTable.innerHTML = '';
            const previewData = parser.data.slice(0, 20);
            
            previewData.forEach(function(record) {
                if (record.type === 'method_code') return;
                
                const row = document.createElement('tr');
                
                // Point cell
                const pointCell = document.createElement('td');
                pointCell.textContent = record.words['11'] ? record.words['11'].value : '';
                
                // Type cell with badge
                const typeCell = document.createElement('td');
                const typeBadge = document.createElement('span');
                typeBadge.className = `type-badge type-${record.type}`;
                typeBadge.textContent = record.type;
                typeCell.appendChild(typeBadge);
                
                // Reading cell
                const readingCell = document.createElement('td');
                let reading = '';
                ['330', '331', '332', '333'].forEach(wi => {
                    if (record.words[wi]) reading = record.words[wi].value.toFixed(5);
                });
                readingCell.textContent = reading;
                
                // Distance cell
                const distanceCell = document.createElement('td');
                const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                distanceCell.textContent = distance;
                
                // Height cell
                const heightCell = document.createElement('td');
                const height = record.words['83'] ? record.words['83'].value.toFixed(4) : '';
                heightCell.textContent = height;
                
                // Setup cell
                const setupCell = document.createElement('td');
                setupCell.textContent = record.setupNumber || '';
                
                row.appendChild(pointCell);
                row.appendChild(typeCell);
                row.appendChild(readingCell);
                row.appendChild(distanceCell);
                row.appendChild(heightCell);
                row.appendChild(setupCell);
                
                elements.dataTable.appendChild(row);
            });

            // Show sections
            elements.statsSection.classList.remove('hidden');
            elements.actionsSection.classList.remove('hidden');
            elements.previewSection.classList.remove('hidden');
        }

        function showOutput(content) {
            currentOutput = content;
            elements.outputArea.textContent = content;
            elements.outputSection.classList.remove('hidden');
        }

        async function downloadOutput() {
            try {
                const blob = new Blob([currentOutput], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `gsi_export_${new Date().toISOString().slice(0, 10)}.txt`;
                
                // Trigger download
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Clean up
                URL.revokeObjectURL(url);
                
                // Visual feedback
                const originalText = elements.downloadBtn.textContent;
                elements.downloadBtn.textContent = '✓ Downloaded';
                setTimeout(() => {
                    elements.downloadBtn.textContent = originalText;
                }, 2000);
                
            } catch (error) {
                console.error('Download error:', error);
                showStatus('✗ Download failed', 'error');
            }
        }

        async function copyOutput() {
            try {
                await navigator.clipboard.writeText(currentOutput);
                
                const originalText = elements.copyBtn.textContent;
                elements.copyBtn.textContent = '✓ Copied';
                setTimeout(() => {
                    elements.copyBtn.textContent = originalText;
                }, 2000);
                
            } catch (error) {
                console.error('Copy error:', error);
                
                // Fallback for older browsers
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = currentOutput;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    const originalText = elements.copyBtn.textContent;
                    elements.copyBtn.textContent = '✓ Copied';
                    setTimeout(() => {
                        elements.copyBtn.textContent = originalText;
                    }, 2000);
                    
                } catch (fallbackError) {
                    console.error('Fallback copy error:', fallbackError);
                    showStatus('✗ Copy failed - please select and copy manually', 'error');
                }
            }
        }

        // Error handling for unhandled promises
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            showStatus('✗ An unexpected error occurred', 'error');
            event.preventDefault();
        });

        // Error handling for general errors
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            showStatus('✗ An unexpected error occurred', 'error');
        });

        // Initialize the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }

    </script>
</body>
</html>