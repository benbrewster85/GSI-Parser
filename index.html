<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSI Level Parser</title>
    <style>
        :root {
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-light: #2a2a2a;
            --text: #ffffff;
            --text-dim: #888888;
            --accent: #00ff88;
            --accent-dim: #00cc6a;
            --border: #333333;
        }

        [data-theme="light"] {
            --bg: #f5f5f5;
            --surface: #ffffff;
            --surface-light: #f8f9fa;
            --text: #1a1a1a;
            --text-dim: #666666;
            --accent: #0066cc;
            --accent-dim: #0052a3;
            --border: #e0e0e0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .theme-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
        }

        .upload-area {
            background: var(--surface);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .upload-area.dragover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .file-input { display: none; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-top: 5px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .btn.primary {
            background: var(--accent);
            color: var(--bg);
        }

        .data-table {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .table-header {
            background: var(--surface-light);
            padding: 15px 20px;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            font-family: inherit;
            font-size: 13px;
        }

        th {
            background: var(--surface-light);
            font-weight: bold;
            color: var(--text-dim);
        }

        tr:hover {
            background: var(--surface-light);
        }

        .output {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            font-family: inherit;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-bottom: 15px;
        }

        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 14px;
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .status.error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .hidden {
            display: none;
        }

        .section { margin-bottom: 30px; }

        .type-badge {
            background: var(--surface-light);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        .type-backsight { background: rgba(0, 255, 136, 0.2); color: var(--accent); }
        .type-foresight { background: rgba(255, 165, 0, 0.2); color: #ffa500; }
        .type-intermediate { background: rgba(0, 123, 255, 0.2); color: #007bff; }

        /* Advanced section styles */
        .section-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--text);
        }

        .advanced-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px;
        }

        .advanced-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }

        .advanced-group h4 {
            margin-bottom: 15px;
            color: var(--text);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
        }

        .help-text {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 15px;
        }

        /* Control Points Table - REMOVED */
        .control-points-container {
            display: none;
        }

        .control-point-row {
            display: none;
        }

        .control-point-input {
            display: none;
        }

        .control-point-select {
            display: none;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 3px;
        }

        .residual-flag {
            color: #ff6b6b;
            font-weight: bold;
        }

        .residual-ok {
            color: var(--accent);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">‚ö° GSI.PARSER</div>
            <button class="theme-btn" id="themeBtn">üåì</button>
        </div>

        <div class="section">
            <div class="upload-area" id="uploadArea">
                <div style="font-size: 36px; margin-bottom: 10px;">üìÅ</div>
                <div>Drop GSI file here or click to select</div>
                <div style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
                    Supports .gsi, .txt, and other level data formats
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".gsi,.txt,.dat,.raw">
            </div>
            <div id="status" class="status hidden"></div>
        </div>

        <div class="section hidden" id="statsSection">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="recordCount">0</div>
                    <div class="stat-label">Records</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="pointCount">0</div>
                    <div class="stat-label">Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="methodType">‚Äî</div>
                    <div class="stat-label">Method</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="heightRange">‚Äî</div>
                    <div class="stat-label">Height Range</div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="actionsSection">
            <div class="actions">
                <button class="btn primary" id="reportBtn">üìÑ Report</button>
                <button class="btn" id="starnetBtn">‚≠ê StarNet</button>
                <button class="btn" id="csvBtn">üìä CSV</button>
                <button class="btn" id="advancedBtn">‚öôÔ∏è Advanced</button>
            </div>
        </div>

        <!-- Advanced Processing Section -->
        <div class="section hidden" id="advancedSection">
            <div class="section-title">
                ‚öôÔ∏è Advanced Processing Options
                <button class="btn" id="advancedToggle">Hide</button>
            </div>
            
            <div class="advanced-content">
                <div class="advanced-grid">
                    <div class="advanced-group">
                        <h4>Change Point Processing</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="aggregateCP" checked>
                            <span>Aggregate change point readings</span>
                        </label>
                        <p class="help-text">
                            Groups readings between named stations through change points
                        </p>
                        
                        <label class="form-label">Change Point Prefix:</label>
                        <input type="text" id="changePointPrefix" value="CP" placeholder="e.g., CP, TP, TBM" class="form-input">
                    </div>
                    
                    <div class="advanced-group">
                        <h4>Output Options</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="includeTurnCount">
                            <span>Include turn count in reports</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showCPDetails">
                            <span>Show change point details</span>
                        </label>
                        
                        <button class="btn primary" id="applyAdvanced" style="margin-top: 10px;">Apply & Reprocess</button>
                    </div>
                </div>



                <!-- Adjustment Options - REMOVED FOR NOW -->
                <!--
                <div style="grid-column: 1 / -1; margin-top: 20px;">
                    <h4 style="margin-bottom: 15px; color: var(--text);">‚öñÔ∏è Adjustment Method</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <label class="checkbox-label">
                                <input type="radio" name="adjustmentMethod" value="none" checked style="width: 16px; height: 16px;">
                                <span>No Adjustment</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="adjustmentMethod" value="equal" style="width: 16px; height: 16px;">
                                <span>Equal Distribution</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="adjustmentMethod" value="proportional" style="width: 16px; height: 16px;">
                                <span>Distance Weighted</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="adjustmentMethod" value="constrained" style="width: 16px; height: 16px;">
                                <span>Control Constrained</span>
                            </label>
                        </div>
                        <div>
                            <label class="form-label">Benchmark Tolerance (m):</label>
                            <input type="number" id="benchmarkTolerance" value="0.020" step="0.001" class="form-input" style="margin-bottom: 10px;">
                            
                            <label class="form-label">Flag Large Residuals (m):</label>
                            <input type="number" id="residualThreshold" value="0.015" step="0.001" class="form-input">
                        </div>
                    </div>
                </div>
                -->
            </div>
        </div>

        <div class="section hidden" id="previewSection">
            <div class="data-table">
                <div class="table-header">Data Preview</div>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Point</th>
                                <th>Type</th>
                                <th>Reading</th>
                                <th>Distance</th>
                                <th>Height</th>
                                <th>Setup</th>
                            </tr>
                        </thead>
                        <tbody id="dataTable"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="section hidden" id="outputSection">
            <div class="output" id="outputArea"></div>
            <div>
                <button class="btn" id="downloadBtn">üíæ Download</button>
                <button class="btn" id="copyBtn">üìã Copy</button>
            </div>
        </div>

        <!-- Footer -->
        <div style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid var(--border); color: var(--text-dim); font-size: 12px;">
            Created by Ben Brewster 2025
        </div>
    </div>

    <script>
        // Test if JavaScript is running
        console.log('GSI Parser JavaScript is loading...');

        class GSIParser {
            constructor() {
                this.data = [];
                this.rawData = '';
                this.stats = {};
                this.processingOptions = {
                    aggregateCP: true,
                    changePointPrefix: 'CP',
                    includeTurnCount: false,
                    showCPDetails: false,
                    adjustmentMethod: 'none',
                    benchmarkTolerance: 0.020,
                    residualThreshold: 0.015
                };
            }

            parse(text) {
                this.rawData = text; // Store raw data for reprocessing
                this.data = [];
                const lines = text.split('\n');
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const record = this.parseLine(line);
                    if (record) {
                        record.lineNumber = i + 1;
                        this.data.push(record);
                    }
                }
                
                this.calculateStats();
                return this.data;
            }

            reprocess() {
                if (!this.rawData) return;
                return this.parse(this.rawData);
            }

            updateProcessingOptions(options) {
                this.processingOptions = { ...this.processingOptions, ...options };
                const result = this.reprocess();
                // Recalculate aggregated runs with new options
                this.aggregatedRuns = this.aggregateChangePointRuns();
                return result;
            }



            parseLine(line) {
                const words = line.split(/\s+/);
                const record = { words: {}, type: 'unknown' };
                
                for (const word of words) {
                    const parsed = this.parseWord(word);
                    if (parsed) {
                        record.words[parsed.wi] = parsed;
                    }
                }
                
                // Determine record type
                if (record.words['331']) record.type = 'backsight';
                else if (record.words['332']) record.type = 'foresight';
                else if (record.words['333']) record.type = 'intermediate';
                else if (record.words['330']) record.type = 'measure_only';
                
                return Object.keys(record.words).length > 0 ? record : null;
            }

            parseWord(word) {
                if (word.length < 8) return null;
                
                let wi, info, sign, data;
                
                if (word.startsWith('*')) {
                    // GSI-16 format
                    wi = word.substring(1, 3);
                    info = word.substring(3, 7);
                    sign = word.substring(7, 8);
                    data = word.substring(8);
                } else {
                    // Check if it's a 3-digit WI (like 331, 332, 333)
                    // These have the pattern: digit-digit-digit-dot
                    const first3 = word.substring(0, 3);
                    const fourth = word.substring(3, 4);
                    
                    if (!isNaN(first3) && fourth === '.' && first3.length === 3 && 
                        parseInt(first3) >= 330 && parseInt(first3) <= 399) {
                        // 3-digit WI like 331.28+... (staff readings)
                        wi = first3;
                        info = word.substring(3, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    } else {
                        // 2-digit WI like 32...8+... or 11+...
                        // Extract just the first 2 digits as WI, ignore any dots in info
                        wi = word.substring(0, 2);
                        info = word.substring(2, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    }
                }
                
                const value = this.interpretValue(wi, sign + data, info);
                return { wi, info, sign, data, value };
            }

            interpretValue(wi, valueStr, info) {
                if (wi === '11') {
                    return valueStr.replace(/^[+\-0]*/, '').replace(/^0+/, '') || valueStr;
                }
                
                const num = parseInt(valueStr);
                if (isNaN(num)) return 0;
                
                // Use position 6 for scale factor
                const pos6 = info.charAt(info.length - 1);
                let scale = 1000;
                if (pos6 === '6') scale = 10000;
                else if (pos6 === '8') scale = 100000;
                
                // Don't scale count values
                if (['390', '391', '392'].includes(wi)) return num;
                
                return num / scale;
            }

            calculateStats() {
                const points = new Set();
                const heights = [];
                let setupCount = 0;
                
                // Build level runs for better analysis
                this.levelRuns = this.buildLevelRuns();
                this.aggregatedRuns = this.aggregateChangePointRuns();
                
                this.data.forEach(record => {
                    if (record.words['11']) {
                        points.add(record.words['11'].value);
                    }
                    if (record.words['83']) {
                        heights.push(record.words['83'].value);
                    }
                    if (record.type === 'backsight') {
                        setupCount++;
                    }
                });
                
                this.stats.recordCount = this.data.length;
                this.stats.pointCount = points.size;
                this.stats.setupCount = setupCount;
                this.stats.uniquePoints = Array.from(points);
                
                if (heights.length > 0) {
                    const min = Math.min(...heights);
                    const max = Math.max(...heights);
                    this.stats.heightRange = min.toFixed(3) + 'm - ' + max.toFixed(3) + 'm';
                } else {
                    this.stats.heightRange = '‚Äî';
                }
                
                // Detect method
                const methodRecord = this.data.find(r => r.words['41'] && r.words['41'].data.includes('?'));
                if (methodRecord) {
                    const code = methodRecord.words['41'].data;
                    if (code.includes('1')) this.stats.method = 'BF';
                    else if (code.includes('2')) this.stats.method = 'BFFB';
                    else this.stats.method = 'Unknown';
                } else {
                    this.stats.method = '‚Äî';
                }
            }

            buildLevelRuns() {
                const runs = [];
                let currentRun = null;
                let setupNumber = 0;
                
                this.data.forEach((record, index) => {
                    record.setupNumber = setupNumber;
                    
                    if (record.type === 'backsight') {
                        if (currentRun) {
                            runs.push(currentRun);
                        }
                        setupNumber++;
                        currentRun = {
                            setupNumber: setupNumber,
                            backsight: record,
                            foresights: [],
                            intermediates: []
                        };
                        record.setupNumber = setupNumber;
                    } else if (currentRun) {
                        if (record.type === 'foresight') {
                            currentRun.foresights.push(record);
                            record.setupNumber = setupNumber;
                        } else if (record.type === 'intermediate') {
                            currentRun.intermediates.push(record);
                            record.setupNumber = setupNumber;
                        }
                    }
                });
                
                if (currentRun) {
                    runs.push(currentRun);
                }
                
                return runs;
            }

            aggregateChangePointRuns() {
                if (!this.processingOptions.aggregateCP) {
                    return this.levelRuns;
                }

                const aggregatedRuns = [];
                const prefix = this.processingOptions.changePointPrefix.toUpperCase();
                
                // Group consecutive runs that form a change point sequence
                let i = 0;
                while (i < this.levelRuns.length) {
                    const currentRun = this.levelRuns[i];
                    
                    // Check if this starts a change point sequence
                    const bsPoint = currentRun.backsight.words['11'] ? currentRun.backsight.words['11'].value.toUpperCase() : '';
                    const isStartOfSequence = !bsPoint.startsWith(prefix) && 
                        currentRun.foresights.some(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                            return fsPoint.startsWith(prefix);
                        });
                    
                    if (!isStartOfSequence) {
                        // Not a change point sequence, add as-is
                        aggregatedRuns.push(currentRun);
                        i++;
                        continue;
                    }
                    
                    // Find the end of the change point sequence
                    let sequenceRuns = [currentRun];
                    let j = i + 1;
                    
                    while (j < this.levelRuns.length) {
                        const nextRun = this.levelRuns[j];
                        const nextBsPoint = nextRun.backsight.words['11'] ? nextRun.backsight.words['11'].value.toUpperCase() : '';
                        
                        if (nextBsPoint.startsWith(prefix)) {
                            sequenceRuns.push(nextRun);
                            j++;
                        } else {
                            break;
                        }
                    }
                    
                    // Create aggregated run from the sequence
                    const firstRun = sequenceRuns[0];
                    const lastRun = sequenceRuns[sequenceRuns.length - 1];
                    
                    // Find the final non-CP foresight
                    const finalForesight = lastRun.foresights.find(fs => {
                        const fsPoint = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                        return !fsPoint.startsWith(prefix);
                    });
                    
                    if (finalForesight) {
                        // Calculate total distance and height difference across all runs
                        let totalDistance = 0;
                        let totalHeightDiff = 0;
                        let changePointCount = 0;
                        
                        sequenceRuns.forEach(run => {
                            const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                            const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                            totalDistance += bsDistance;
                            
                            run.foresights.forEach(fs => {
                                const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                                const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                                const fsPoint = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                                
                                totalDistance += fsDistance;
                                totalHeightDiff += (bsReading - fsReading);
                                
                                if (fsPoint.startsWith(prefix)) {
                                    changePointCount++;
                                }
                            });
                        });
                        
                        const aggregatedRun = {
                            setupNumber: firstRun.setupNumber,
                            backsight: firstRun.backsight,
                            foresights: [finalForesight],
                            intermediates: [],
                            totalTurns: changePointCount + 1,
                            totalDistance: totalDistance,
                            totalHeightDiff: totalHeightDiff,
                            isAggregated: true
                        };
                        
                        aggregatedRuns.push(aggregatedRun);
                    } else {
                        // No final non-CP point found, add runs as-is
                        sequenceRuns.forEach(run => aggregatedRuns.push(run));
                    }
                    
                    i = j;
                }

                return aggregatedRuns;
            }

            processChangePointSequence(run, aggregatedRuns, prefix) {
                // Find the sequence: Named BS ‚Üí CPs ‚Üí Named FS
                const backsight = run.backsight;
                const bsPointId = backsight.words['11'] ? backsight.words['11'].value.toUpperCase() : '';
                
                // Skip if backsight is itself a change point
                if (bsPointId.startsWith(prefix)) {
                    aggregatedRuns.push(run);
                    return;
                }

                // Find the final foresight (non-change point)
                const finalForesight = run.foresights.find(fs => {
                    const fsPointId = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                    return !fsPointId.startsWith(prefix);
                });

                if (!finalForesight) {
                    // No named foresight found, use as-is
                    aggregatedRuns.push(run);
                    return;
                }

                // Count turns: BS ‚Üí CP1 ‚Üí CP2 ‚Üí ... ‚Üí FS
                const changePoints = run.foresights.filter(fs => {
                    const fsPointId = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                    return fsPointId.startsWith(prefix);
                });

                const totalTurns = changePoints.length + 1; // CPs + final turn to named point

                // Create aggregated observation
                const aggregatedRun = {
                    setupNumber: run.setupNumber,
                    backsight: backsight,
                    foresights: [finalForesight],
                    intermediates: run.intermediates.filter(is => {
                        const isPointId = is.words['11'] ? is.words['11'].value.toUpperCase() : '';
                        return !isPointId.startsWith(prefix);
                    }),
                    changePoints: changePoints,
                    totalTurns: totalTurns,
                    isAggregated: true
                };

                aggregatedRuns.push(aggregatedRun);
            }

            generateReport() {
                let report = 'LEVELING REPORT\n';
                report += '================\n\n';
                report += 'Generated: ' + new Date().toLocaleString() + '\n';
                report += 'Records: ' + this.stats.recordCount + '\n';
                report += 'Points: ' + this.stats.pointCount + '\n';
                report += 'Setups: ' + this.stats.setupCount + '\n';
                report += 'Method: ' + this.stats.method + '\n';
                report += 'Height Range: ' + this.stats.heightRange + '\n';
                
                // Add processing options info
                if (this.processingOptions.aggregateCP) {
                    report += 'Change Point Processing: Enabled (Prefix: ' + this.processingOptions.changePointPrefix + ')\n';
                }
                
                report += '\n';
                
                report += 'POINT          TYPE          READING       DISTANCE      HEIGHT        SETUP\n';
                report += '-----------------------------------------------------------------------\n';
                
                this.data.forEach(record => {
                    const point = record.words['11'] ? record.words['11'].value : '';
                    const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                    let height = '';
                    const setup = record.setupNumber || '';
                    
                    // Use adjusted elevation if available
                    if (record.words['83']) {
                        height = record.words['83'].value.toFixed(4);
                    }
                    
                    let reading = '';
                    if (record.words['330']) reading = record.words['330'].value.toFixed(5);
                    else if (record.words['331']) reading = record.words['331'].value.toFixed(5);
                    else if (record.words['332']) reading = record.words['332'].value.toFixed(5);
                    else if (record.words['333']) reading = record.words['333'].value.toFixed(5);
                    
                    if (point || reading || distance || height) {
                        report += point.padEnd(14) + ' ';
                        report += record.type.padEnd(13) + ' ';
                        report += reading.padStart(13) + ' ';
                        report += distance.padStart(13) + ' ';
                        report += height.padStart(13) + ' ';
                        report += setup.toString().padStart(5) + '\n';
                    }
                });
                
                // Add level run summary
                if (this.levelRuns && this.levelRuns.length > 0) {
                    report += '\nLEVEL RUN SUMMARY\n';
                    report += '==================\n\n';
                    
                    const runsToShow = this.processingOptions.aggregateCP ? this.aggregatedRuns : this.levelRuns;
                    
                    runsToShow.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value.toFixed(5) : '';
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value.toFixed(3) : '';
                        
                        report += 'Setup ' + run.setupNumber + ':\n';
                        report += '  BS: ' + bsPoint + ' (' + bsReading + 'm @ ' + bsDistance + 'm)\n';
                        
                        // Show change point details if enabled
                        if (this.processingOptions.showCPDetails && run.changePoints && run.changePoints.length > 0) {
                            run.changePoints.forEach(cp => {
                                const cpPoint = cp.words['11'] ? cp.words['11'].value : '';
                                const cpReading = cp.words['332'] ? cp.words['332'].value.toFixed(5) : '';
                                const cpDistance = cp.words['32'] ? cp.words['32'].value.toFixed(3) : '';
                                report += '  CP: ' + cpPoint + ' (' + cpReading + 'm @ ' + cpDistance + 'm)\n';
                            });
                        }
                        
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value.toFixed(5) : '';
                            const fsDistance = fs.words['32'] ? fs.words['32'].value.toFixed(3) : '';
                            const heightDiff = run.backsight.words['331'] && fs.words['332'] ? 
                                (run.backsight.words['331'].value - fs.words['332'].value).toFixed(5) : '';
                            
                            let fsLine = '  FS: ' + fsPoint + ' (' + fsReading + 'm @ ' + fsDistance + 'm) Œîh=' + heightDiff + 'm';
                            
                            // Add turn count if enabled and aggregated
                            if (this.processingOptions.includeTurnCount && run.isAggregated && run.totalTurns > 1) {
                                fsLine += ' [' + run.totalTurns + ' turns]';
                            }
                            
                            report += fsLine + '\n';
                        });
                        
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isReading = is.words['333'] ? is.words['333'].value.toFixed(5) : '';
                            const isDistance = is.words['32'] ? is.words['32'].value.toFixed(3) : '';
                            
                            report += '  IS: ' + isPoint + ' (' + isReading + 'm @ ' + isDistance + 'm)\n';
                        });
                        
                        report += '\n';
                    });
                }
                
                return report;
            }

            exportStarNet() {
                let output = '# GSI Level Data Export\n';
                output += '# Generated: ' + new Date().toLocaleString() + '\n';
                output += '# Method: ' + this.stats.method + '\n';
                output += '# Setups: ' + this.stats.setupCount + '\n\n';
                
                // Units and settings
                output += '.UNITS METERS\n';
                output += '.HORIZONTAL OBSERVATIONS\n\n';
                
                // Find first point with height as benchmark
                const firstPoint = this.data.find(r => r.words['11'] && r.words['83']);
                if (firstPoint) {
                    output += 'F ' + firstPoint.words['11'].value + ' ' + firstPoint.words['83'].value.toFixed(4) + '\n\n';
                }
                
                // Process level runs to create proper leveling observations
                const runsToProcess = (this.processingOptions.aggregateCP && this.aggregatedRuns) ? 
                    this.aggregatedRuns : this.levelRuns;
                
                if (runsToProcess && runsToProcess.length > 0) {
                    runsToProcess.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                        
                        // Create leveling observations for each foresight
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                            const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                            
                            if (bsPoint && fsPoint) {
                                let heightDiff, totalDistance;
                                
                                if (run.isAggregated) {
                                    // Use pre-calculated values for aggregated runs
                                    heightDiff = run.totalHeightDiff;
                                    totalDistance = run.totalDistance;
                                } else {
                                    // Calculate normally for non-aggregated runs
                                    heightDiff = bsReading - fsReading;
                                    totalDistance = bsDistance + fsDistance;
                                }
                                
                                // Add setup info as comment
                                let comment = '# Setup ' + run.setupNumber + ': ';
                                
                                if (run.isAggregated && run.totalTurns > 1) {
                                    comment += 'Aggregated ' + run.totalTurns + ' turns, Total distance=' + totalDistance.toFixed(3) + 'm';
                                } else {
                                    comment += 'BS=' + bsDistance.toFixed(3) + 'm, FS=' + fsDistance.toFixed(3) + 'm';
                                }
                                
                                output += comment + '\n';
                                
                                // StarNet leveling observation: L From-To ElevDiff Distance
                                output += 'L ' + bsPoint + '-' + fsPoint + ' ' + heightDiff.toFixed(5) + ' ' + totalDistance.toFixed(3) + '\n';
                            }
                        });
                        
                        // Create height observations for intermediate sights
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isHeight = is.words['83'] ? is.words['83'].value : null;
                            
                            if (isPoint && isHeight !== null) {
                                output += '# Intermediate sight\n';
                                output += 'H ' + isPoint + ' ' + isHeight.toFixed(4) + '\n';
                            }
                        });
                        
                        output += '\n';
                    });
                } else {
                    // Fallback: simple height differences
                    let lastPoint = null;
                    let lastHeight = null;
                    let lastDistance = 0;
                    
                    this.data.forEach(record => {
                        if (record.words['11'] && record.words['83']) {
                            const point = record.words['11'].value;
                            const height = record.words['83'].value;
                            const distance = record.words['32'] ? record.words['32'].value : 0;
                            
                            if (lastPoint && lastHeight !== null) {
                                const heightDiff = height - lastHeight;
                                const totalDist = lastDistance + distance;
                                
                                output += 'L ' + lastPoint + '-' + point + ' ' + heightDiff.toFixed(5) + ' ' + totalDist.toFixed(3) + '\n';
                            }
                            
                            if (record.type === 'foresight') {
                                lastPoint = point;
                                lastHeight = height;
                                lastDistance = distance;
                            }
                        }
                    });
                }
                
                output += '\n# End of level data\n';
                return output;
            }

            exportCSV() {
                let csv = 'Point,Type,Reading,Distance,Height,Setup,Line\n';
                
                this.data.forEach(record => {
                    const point = record.words['11'] ? record.words['11'].value : '';
                    const distance = record.words['32'] ? record.words['32'].value : '';
                    const height = record.words['83'] ? record.words['83'].value : '';
                    const setup = record.setupNumber || '';
                    
                    let reading = '';
                    if (record.words['330']) reading = record.words['330'].value;
                    else if (record.words['331']) reading = record.words['331'].value;
                    else if (record.words['332']) reading = record.words['332'].value;
                    else if (record.words['333']) reading = record.words['333'].value;
                    
                    csv += '"' + point + '","' + record.type + '","' + reading + '","' + distance + '","' + height + '","' + setup + '","' + record.lineNumber + '"\n';
                });
                
                return csv;
            }
        }

        // App state
        let parser = new GSIParser();
        let currentOutput = '';
        let currentExtension = 'txt';

        // DOM elements
        const themeBtn = document.getElementById('themeBtn');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const statsSection = document.getElementById('statsSection');
        const actionsSection = document.getElementById('actionsSection');
        const previewSection = document.getElementById('previewSection');
        const outputSection = document.getElementById('outputSection');
        const dataTable = document.getElementById('dataTable');
        const outputArea = document.getElementById('outputArea');
        const recordCount = document.getElementById('recordCount');
        const pointCount = document.getElementById('pointCount');
        const methodType = document.getElementById('methodType');
        const heightRange = document.getElementById('heightRange');
        const reportBtn = document.getElementById('reportBtn');
        const starnetBtn = document.getElementById('starnetBtn');
        const csvBtn = document.getElementById('csvBtn');
        const advancedBtn = document.getElementById('advancedBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const copyBtn = document.getElementById('copyBtn');

        // Advanced section elements
        const advancedSection = document.getElementById('advancedSection');
        const advancedToggle = document.getElementById('advancedToggle');
        const applyAdvanced = document.getElementById('applyAdvanced');
        const aggregateCP = document.getElementById('aggregateCP');
        const changePointPrefix = document.getElementById('changePointPrefix');
        const includeTurnCount = document.getElementById('includeTurnCount');
        const showCPDetails = document.getElementById('showCPDetails');

        // Control points elements - REMOVED
        // const controlPointsTable = document.getElementById('controlPointsTable');
        // const addControlPoint = document.getElementById('addControlPoint');
        // const detectControlPoints = document.getElementById('detectControlPoints');
        // const importControlBtn = document.getElementById('importControlBtn');
        // const importControlCSV = document.getElementById('importControlCSV');

        console.log('Advanced section elements check:');
        console.log('advancedSection found:', !!advancedSection);
        console.log('advancedBtn found:', !!advancedBtn);
        console.log('applyAdvanced found:', !!applyAdvanced);

        // Theme toggle
        themeBtn.addEventListener('click', function() {
            const current = document.documentElement.getAttribute('data-theme');
            const newTheme = current === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });

        // Load saved theme
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);

        // File upload
        uploadArea.addEventListener('click', function() {
            fileInput.click();
        });

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });

        // Advanced options event listeners
        advancedBtn.addEventListener('click', function() {
            console.log('Advanced button clicked');
            advancedSection.classList.toggle('hidden');
            advancedBtn.textContent = advancedSection.classList.contains('hidden') ? '‚öôÔ∏è Advanced' : '‚öôÔ∏è Hide Advanced';
        });

        advancedToggle.addEventListener('click', function() {
            console.log('Advanced toggle clicked');
            advancedSection.classList.add('hidden');
            advancedBtn.textContent = '‚öôÔ∏è Advanced';
        });

        // FIXED - Complete applyAdvanced event listener
        applyAdvanced.addEventListener('click', function() {
            console.log('Apply advanced clicked');
            
            // Update processing options
            const newOptions = {
                aggregateCP: aggregateCP.checked,
                changePointPrefix: changePointPrefix.value || 'CP',
                includeTurnCount: includeTurnCount.checked,
                showCPDetails: showCPDetails.checked
            };
            
            console.log('New options:', newOptions);
            
            try {
                parser.updateProcessingOptions(newOptions);
                showStatus('‚úì Data reprocessed with new options', 'success');
                updateUI();
                
                // Clear any existing output
                outputSection.classList.add('hidden');
                
                // Subtle acknowledgement in the apply button
                applyAdvanced.textContent = '‚úì Applied';
                applyAdvanced.style.background = 'var(--accent)';
                applyAdvanced.style.color = 'var(--bg)';
                
                setTimeout(function() {
                    applyAdvanced.textContent = 'Apply & Reprocess';
                    applyAdvanced.style.background = '';
                    applyAdvanced.style.color = '';
                }, 2000);
                
            } catch (error) {
                console.error('Reprocessing error:', error);
                showStatus('‚úó Error reprocessing: ' + error.message, 'error');
            }
        });




        function processFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    parser.parse(e.target.result);
                    showStatus('‚úì Parsed ' + parser.data.length + ' records', 'success');
                    updateUI();
                } catch (error) {
                    showStatus('‚úó Error: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
            status.classList.remove('hidden');
        }

        function updateUI() {
            // Update stats
            recordCount.textContent = parser.stats.recordCount;
            pointCount.textContent = parser.stats.pointCount;
            methodType.textContent = parser.stats.method;
            heightRange.textContent = parser.stats.heightRange;

            // Update table
            dataTable.innerHTML = '';
            parser.data.slice(0, 20).forEach(function(record) {
                if (record.type === 'method_code') return; // Skip method codes
                
                const row = document.createElement('tr');
                const point = record.words['11'] ? record.words['11'].value : '';
                const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                const height = record.words['83'] ? record.words['83'].value.toFixed(4) : '';
                
                let reading = '';
                if (record.words['330']) reading = record.words['330'].value.toFixed(5);
                else if (record.words['331']) reading = record.words['331'].value.toFixed(5);
                else if (record.words['332']) reading = record.words['332'].value.toFixed(5);
                else if (record.words['333']) reading = record.words['333'].value.toFixed(5);
                
                row.innerHTML = '<td>' + point + '</td>' +
                    '<td><span class="type-badge type-' + record.type + '">' + record.type + '</span></td>' +
                    '<td>' + reading + '</td>' +
                    '<td>' + distance + '</td>' +
                    '<td>' + height + '</td>' +
                    '<td>' + (record.setupNumber || '') + '</td>';
                
                dataTable.appendChild(row);
            });

            // Show sections
            statsSection.classList.remove('hidden');
            actionsSection.classList.remove('hidden');
            previewSection.classList.remove('hidden');
        }

        function showOutput(content) {
            currentOutput = content;
            outputArea.textContent = content;
            outputSection.classList.remove('hidden');
        }

        // Button handlers
        reportBtn.addEventListener('click', function() {
            showOutput(parser.generateReport());
        });

        starnetBtn.addEventListener('click', function() {
            showOutput(parser.exportStarNet());
        });

        csvBtn.addEventListener('click', function() {
            showOutput(parser.exportCSV());
        });

        downloadBtn.addEventListener('click', function() {
            const blob = new Blob([currentOutput], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gsi_export_' + new Date().toISOString().slice(0, 10) + '.txt';
            a.click();
            URL.revokeObjectURL(url);
        });

        copyBtn.addEventListener('click', function() {
            navigator.clipboard.writeText(currentOutput).then(function() {
                copyBtn.textContent = '‚úì Copied';
                setTimeout(function() {
                    copyBtn.textContent = 'üìã Copy';
                }, 2000);
            });
        });

        // Initialize empty app state
        console.log('GSI Parser initialized and ready.');
    </script>
</body>
</html>