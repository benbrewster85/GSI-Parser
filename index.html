<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSI Level Parser</title>
    <style>
        :root {
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-light: #2a2a2a;
            --text: #ffffff;
            --text-dim: #888888;
            --accent: #00ff88;
            --accent-dim: #00cc6a;
            --border: #333333;
        }

        [data-theme="light"] {
            --bg: #f5f5f5;
            --surface: #ffffff;
            --surface-light: #f8f9fa;
            --text: #1a1a1a;
            --text-dim: #666666;
            --accent: #0066cc;
            --accent-dim: #0052a3;
            --border: #e0e0e0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .theme-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
        }

        .upload-area {
            background: var(--surface);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .upload-area.dragover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .file-input { display: none; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-top: 5px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg);
        }

        .btn.primary {
            background: var(--accent);
            color: var(--bg);
        }

        .data-table {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .table-header {
            background: var(--surface-light);
            padding: 15px 20px;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            font-family: inherit;
            font-size: 13px;
        }

        th {
            background: var(--surface-light);
            font-weight: bold;
            color: var(--text-dim);
        }

        tr:hover {
            background: var(--surface-light);
        }

        .output {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            font-family: inherit;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-bottom: 15px;
        }

        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 14px;
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .status.error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .status.warning {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid #ffa500;
            color: #ffa500;
        }

        .hidden {
            display: none;
        }

        .section { margin-bottom: 30px; }

        .type-badge {
            background: var(--surface-light);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        .type-backsight { background: rgba(0, 255, 136, 0.2); color: var(--accent); }
        .type-foresight { background: rgba(255, 165, 0, 0.2); color: #ffa500; }
        .type-intermediate { background: rgba(0, 123, 255, 0.2); color: #007bff; }

        /* Advanced section styles */
        .section-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--text);
        }

        .advanced-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px;
        }

        .advanced-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }

        .advanced-group h4 {
            margin-bottom: 15px;
            color: var(--text);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
        }

        .help-text {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 15px;
        }

        /* Control Points Table - REMOVED */
        .control-points-container {
            display: none;
        }

        .control-point-row {
            display: none;
        }

        .control-point-input {
            display: none;
        }

        .control-point-select {
            display: none;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 3px;
        }

        .residual-flag {
            color: #ff6b6b;
            font-weight: bold;
        }

        .residual-ok {
            color: var(--accent);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">‚ö° GSI.PARSER</div>
            <button class="theme-btn" id="themeBtn">üåì</button>
        </div>

        <div class="section">
            <div class="upload-area" id="uploadArea">
                <div style="font-size: 36px; margin-bottom: 10px;">üìÅ</div>
                <div>Drop GSI file here or click to select</div>
                <div style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
                    Supports .gsi, .txt, and other level data formats
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".gsi,.txt,.dat,.raw">
            </div>
            <div id="status" class="status hidden"></div>
        </div>

        <div class="section hidden" id="statsSection">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="recordCount">0</div>
                    <div class="stat-label">Records</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="pointCount">0</div>
                    <div class="stat-label">Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="methodType">‚Äî</div>
                    <div class="stat-label">Method</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="heightRange">‚Äî</div>
                    <div class="stat-label">Height Range</div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="actionsSection">
            <div class="actions">
                <button class="btn primary" id="reportBtn">üìÑ Report</button>
                <button class="btn" id="starnetBtn">‚≠ê StarNet</button>
                <button class="btn" id="csvBtn">üìä CSV</button>
                <button class="btn" id="advancedBtn">‚öôÔ∏è Advanced</button>
            </div>
        </div>

        <!-- Advanced Processing Section -->
        <div class="section hidden" id="advancedSection">
            <div class="section-title">
                ‚öôÔ∏è Advanced Processing Options
                <button class="btn" id="advancedToggle">Hide</button>
            </div>
            
            <div class="advanced-content">
                <div class="advanced-grid">
                    <div class="advanced-group">
                        <h4>Change Point Processing</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="aggregateCP" checked>
                            <span>Aggregate change point readings</span>
                        </label>
                        <p class="help-text">
                            Groups readings between named stations through change points
                        </p>
                        
                        <label class="form-label">Change Point Detection Method:</label>
                        <div style="margin-bottom: 15px;">
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="prefix" checked style="width: 16px; height: 16px;">
                                <span>Text Prefix (e.g., CP, TP, TBM)</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="numeric" style="width: 16px; height: 16px;">
                                <span>Numeric Only (1, 2, 3, 4...)</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="both" style="width: 16px; height: 16px;">
                                <span>Both Methods</span>
                            </label>
                        </div>
                        
                        <div id="prefixSettings">
                            <label class="form-label">Change Point Prefix:</label>
                            <input type="text" id="changePointPrefix" value="CP" placeholder="e.g., CP, TP, TBM" class="form-input">
                        </div>
                        
                        <div id="numericSettings" style="display: none;">
                            <label class="form-label">Numeric Range:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="numericMin" value="1" min="0" max="999" class="form-input" style="width: 80px;" placeholder="Min">
                                <span>to</span>
                                <input type="number" id="numericMax" value="999" min="1" max="9999" class="form-input" style="width: 80px;" placeholder="Max">
                            </div>
                            <p class="help-text">
                                Point names that are purely numeric within this range will be treated as change points
                            </p>
                        </div>
                    </div>
                    
                    <div class="advanced-group">
                        <h4>Output Options</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="includeTurnCount">
                            <span>Include turn count in reports</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showCPDetails">
                            <span>Show change point details</span>
                        </label>
                        
                        <button class="btn primary" id="applyAdvanced" style="margin-top: 10px;">Apply & Reprocess</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="previewSection">
            <div class="data-table">
                <div class="table-header">Data Preview</div>
                <div style="max-height: 400px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Point</th>
                                <th>Type</th>
                                <th>Reading</th>
                                <th>Distance</th>
                                <th>Height</th>
                                <th>Setup</th>
                            </tr>
                        </thead>
                        <tbody id="dataTable"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="section hidden" id="outputSection">
            <div class="output" id="outputArea"></div>
            <div>
                <button class="btn" id="downloadBtn">üíæ Download</button>
                <button class="btn" id="copyBtn">üìã Copy</button>
            </div>
        </div>

        <!-- Footer -->
        <div style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid var(--border); color: var(--text-dim); font-size: 12px;">
            Created by Ben Brewster 2025
        </div>
    </div>

    <script>
    

        class GSIParser {
            constructor() {
                this.data = [];
                this.rawData = '';
                this.stats = {};
                this.processingOptions = {
                    aggregateCP: true,
                    changePointPrefix: 'CP',
                    changePointMethod: 'prefix', // 'prefix', 'numeric', 'both'
                    numericMin: 1,
                    numericMax: 999,
                    includeTurnCount: false,
                    showCPDetails: false,
                    adjustmentMethod: 'none',
                    benchmarkTolerance: 0.020,
                    residualThreshold: 0.015
                };
            }

            parse(text) {
                // Security check: Input size
                if (text.length > MAX_FILE_SIZE) {
                    throw new Error('Input text too large');
                }

                this.rawData = text;
                this.data = [];
                const lines = text.split('\n');
                
                // Security check: Line count
                if (lines.length > MAX_RECORDS) {
                    throw new Error(`Too many lines. Maximum ${MAX_RECORDS} lines allowed.`);
                }

                // GSI Format Validation and Detection
                const formatAnalysis = this.analyzeGSIFormat(lines);
                this.displayFormatWarnings(formatAnalysis);
                
                let processedRecords = 0;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    // Security check: Line length
                    if (line.length > MAX_LINE_LENGTH) {
                        console.warn(`Skipping excessively long line ${i + 1}`);
                        continue;
                    }
                    
                    // Security check: Record limit
                    if (processedRecords >= MAX_RECORDS) {
                        console.warn(`Reached maximum record limit of ${MAX_RECORDS}`);
                        break;
                    }
                    
                    const record = this.parseLine(line);
                    if (record) {
                        record.lineNumber = i + 1;
                        this.data.push(record);
                        processedRecords++;
                    }
                }
                
                this.calculateStats();
                return this.data;
            }

            analyzeGSIFormat(lines) {
                const analysis = {
                    totalLines: lines.length,
                    validGSILines: 0,
                    invalidLines: [],
                    formatType: 'unknown',
                    isTPS: false,
                    hasLevelingData: false,
                    hasCoordinateData: false,
                    wordCounts: {},
                    errors: [],
                    warnings: []
                };

                let sampleValidLines = 0;
                const maxSampleSize = Math.min(50, lines.length); // Analyze first 50 lines for efficiency

                for (let i = 0; i < maxSampleSize; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const lineAnalysis = this.analyzeGSILine(line, i + 1);
                    
                    if (lineAnalysis.isValid) {
                        analysis.validGSILines++;
                        sampleValidLines++;
                        
                        // Collect word IDs for pattern analysis
                        lineAnalysis.wordIds.forEach(wi => {
                            analysis.wordCounts[wi] = (analysis.wordCounts[wi] || 0) + 1;
                        });
                        
                        // Check for specific data types
                        if (lineAnalysis.hasLevelingWords) analysis.hasLevelingData = true;
                        if (lineAnalysis.hasCoordinateWords) analysis.hasCoordinateData = true;
                        
                    } else {
                        analysis.invalidLines.push({
                            lineNumber: i + 1,
                            content: line.substring(0, 100) + (line.length > 100 ? '...' : ''),
                            issues: lineAnalysis.issues
                        });
                    }
                }

                // Determine format type and TPS detection
                this.determineGSIFormat(analysis);
                
                return analysis;
            }

            analyzeGSILine(line, lineNumber) {
                const result = {
                    isValid: false,
                    wordIds: [],
                    hasLevelingWords: false,
                    hasCoordinateWords: false,
                    issues: []
                };

                // Check basic GSI structure
                const words = line.split(/\s+/);
                
                if (words.length === 0) {
                    result.issues.push('Empty line');
                    return result;
                }

                let validWords = 0;
                const levelingWIs = ['331', '332', '333', '330', '83', '84', '85'];
                const coordinateWIs = ['81', '82', '83', '84', '85', '86', '87', '88'];
                const tpsSpecificWIs = ['16', '17', '18', '19', '71', '72', '73', '74', '75', '76'];

                for (const word of words) {
                    if (word.length < 8) {
                        result.issues.push(`Word too short: ${word}`);
                        continue;
                    }

                    // Check GSI word structure
                    let wi, isValidStructure = false;
                    
                    if (word.startsWith('*')) {
                        // GSI-16 format
                        wi = word.substring(1, 3);
                        isValidStructure = /^\*\d{2}[\d\.]{4}[+\-]\d+$/.test(word);
                    } else {
                        // GSI-8 format variations
                        if (/^\d{3}\./.test(word)) {
                            // 3-digit WI (like 331.28+...)
                            wi = word.substring(0, 3);
                            isValidStructure = /^\d{3}\.[\d\.]{2}[+\-]\d+$/.test(word);
                        } else {
                            // 2-digit WI (like 11+...)
                            wi = word.substring(0, 2);
                            isValidStructure = /^\d{2}[\d\.]{4}[+\-]\d+$/.test(word);
                        }
                    }

                    if (isValidStructure && !isNaN(parseInt(wi))) {
                        validWords++;
                        result.wordIds.push(wi);
                        
                        if (levelingWIs.includes(wi)) result.hasLevelingWords = true;
                        if (coordinateWIs.includes(wi)) result.hasCoordinateWords = true;
                    } else {
                        result.issues.push(`Invalid GSI word structure: ${word.substring(0, 20)}`);
                    }
                }

                // A line is valid if it has at least one valid GSI word
                result.isValid = validWords > 0;
                
                return result;
            }

            determineGSIFormat(analysis) {
                // Detect TPS files
                const tpsIndicators = ['16', '17', '18', '19', '58', '59', '71', '72', '73', '74', '75', '76'];
                const coordinateWIs = ['81', '82', '83', '84', '85', '86', '87', '88'];
                const levelingWIs = ['331', '332', '333', '330'];

                const hasTpsWords = tpsIndicators.some(wi => analysis.wordCounts[wi] > 0);
                const hasCoordinates = coordinateWIs.some(wi => analysis.wordCounts[wi] > 0);
                const hasLeveling = levelingWIs.some(wi => analysis.wordCounts[wi] > 0);

                // TPS Detection Logic
                if (hasTpsWords || (hasCoordinates && !hasLeveling)) {
                    analysis.isTPS = true;
                    analysis.formatType = 'TPS';
                    analysis.warnings.push('‚ö†Ô∏è TPS (Total Station) GSI detected - This parser is optimized for leveling data');
                } else if (hasLeveling) {
                    analysis.formatType = 'Leveling';
                } else if (hasCoordinates) {
                    analysis.formatType = 'Coordinate';
                    analysis.warnings.push('‚ö†Ô∏è Coordinate data detected - Limited support for non-leveling GSI');
                }

                // Format validation
                const validLineRatio = analysis.validGSILines / Math.max(1, analysis.totalLines - this.countEmptyLines(analysis));
                
                if (validLineRatio < 0.7) {
                    analysis.errors.push(`‚ùå Poor GSI format: Only ${Math.round(validLineRatio * 100)}% of lines are valid GSI format`);
                }

                if (analysis.validGSILines === 0) {
                    analysis.errors.push('‚ùå No valid GSI data found - Check file format');
                }

                // Specific format warnings
                if (analysis.wordCounts['11'] === 0) {
                    analysis.warnings.push('‚ö†Ô∏è No point IDs (WI 11) found');
                }

                if (Object.keys(analysis.wordCounts).length < 3) {
                    analysis.warnings.push('‚ö†Ô∏è Very limited GSI word types detected');
                }
            }

            countEmptyLines(analysis) {
                return analysis.totalLines - analysis.validGSILines - analysis.invalidLines.length;
            }

            displayFormatWarnings(analysis) {
                const messages = [];

                // Add format detection message
                if (analysis.formatType !== 'unknown') {
                    messages.push(`üìã GSI Format: ${analysis.formatType}`);
                }

                // Add TPS warning
                if (analysis.isTPS) {
                    messages.push('üî∂ TPS GSI Detected: This file appears to contain Total Station data. This parser is specialized for leveling data and may not display all TPS features correctly. We are working on it!');
                }

                // Add errors
                analysis.errors.forEach(error => messages.push(error));
                
                // Add warnings
                analysis.warnings.forEach(warning => messages.push(warning));

                // Add validation summary
                if (analysis.invalidLines.length > 0) {
                //   messages.push(`‚ö†Ô∏è ${analysis.invalidLines.length} lines have formatting issues`);
                    
                    // Show first few invalid lines as examples
                    const exampleCount = Math.min(3, analysis.invalidLines.length);
                    for (let i = 0; i < exampleCount; i++) {
                        const invalid = analysis.invalidLines[i];
                        //messages.push(`   Line ${invalid.lineNumber}: ${invalid.content}`);
                    }
                    
                    if (analysis.invalidLines.length > exampleCount) {
                        messages.push(`   ... and ${analysis.invalidLines.length - exampleCount} more`);
                    }
                }

                // Display all messages
                if (messages.length > 0) {
                    const messageText = messages.join('\n');
                    
                    // Determine message type based on content
                    let messageType = 'success';
                    if (analysis.errors.length > 0) {
                        messageType = 'error';
                    } else if (analysis.warnings.length > 0 || analysis.isTPS) {
                        messageType = 'warning';
                    }
                    
                    // Use a custom status display for format analysis
                    this.showFormatStatus(messageText, messageType);
                }
            }

            showFormatStatus(message, type) {
                // Create or update format status element
                let formatStatus = document.getElementById('formatStatus');
                if (!formatStatus) {
                    formatStatus = document.createElement('div');
                    formatStatus.id = 'formatStatus';
                    formatStatus.className = 'status';
                    
                    // Insert after the main status element
                    const mainStatus = document.getElementById('status');
                    mainStatus.parentNode.insertBefore(formatStatus, mainStatus.nextSibling);
                }
                
                formatStatus.textContent = message;
                formatStatus.className = 'status ' + type;
                formatStatus.classList.remove('hidden');
                formatStatus.style.whiteSpace = 'pre-line'; // Allow line breaks
                formatStatus.style.marginTop = '10px';
                formatStatus.style.fontSize = '13px';
            }

            reprocess() {
                if (!this.rawData) return;
                return this.parse(this.rawData);
            }

            updateProcessingOptions(options) {
                this.processingOptions = { ...this.processingOptions, ...options };
                const result = this.reprocess();
                // Recalculate aggregated runs with new options
                this.aggregatedRuns = this.aggregateChangePointRuns();
                return result;
            }

            parseLine(line) {
                const words = line.split(/\s+/);
                const record = { words: {}, type: 'unknown' };
                
                for (const word of words) {
                    const parsed = this.parseWord(word);
                    if (parsed) {
                        record.words[parsed.wi] = parsed;
                    }
                }
                
                // Determine record type
                if (record.words['331']) record.type = 'backsight';
                else if (record.words['332']) record.type = 'foresight';
                else if (record.words['333']) record.type = 'intermediate';
                else if (record.words['330']) record.type = 'measure_only';
                
                return Object.keys(record.words).length > 0 ? record : null;
            }
// removed some security checks - review this later if needed 
            parseWord(word) {
                if (word.length < 8 || word.length > 100) return null; // Increased max length for longer point names
                
              
                
                let wi, info, sign, data;
                
                if (word.startsWith('*')) {
                    // GSI-16 format
                    wi = word.substring(1, 3);
                    info = word.substring(3, 7);
                    sign = word.substring(7, 8);
                    data = word.substring(8);
                } else {
                    // Check if it's a 3-digit WI (like 331, 332, 333)
                    const first3 = word.substring(0, 3);
                    const fourth = word.substring(3, 4);
                    
                    if (!isNaN(first3) && fourth === '.' && first3.length === 3 && 
                        parseInt(first3) >= 330 && parseInt(first3) <= 399) {
                        wi = first3;
                        info = word.substring(3, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    } else {
                        wi = word.substring(0, 2);
                        info = word.substring(2, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    }
                }
                
                // Security: Validate WI is numeric (but be more lenient)
                if (wi && isNaN(parseInt(wi))) {
                    console.warn('Non-numeric WI detected:', wi, 'in word:', word.substring(0, 20));
                    return null;
                }
                
                const value = this.interpretValue(wi, sign + data, info);
                return { wi, info, sign, data, value };
            }

            interpretValue(wi, valueStr, info) {
                // Handle point names (WI 11) - preserve as text
                if (wi === '11') {
                    // Clean up the value string but preserve alphanumeric characters
                    let cleaned = valueStr.replace(/^[+\-0]*/, ''); // Remove leading +/- and zeros
                    cleaned = cleaned.replace(/^0+/, '') || valueStr; // Remove leading zeros but keep something
                    
                    // If it's still empty or just symbols, return the original
                    if (!cleaned || cleaned.length === 0) {
                        cleaned = valueStr;
                    }
                    
                    return cleaned;
                }
                
                // Handle numeric values
                const num = parseInt(valueStr);
                if (isNaN(num)) {
                    console.warn('Non-numeric value for WI', wi, ':', valueStr);
                    return 0;
                }
                
                // Use position 6 for scale factor
                const pos6 = info.charAt(info.length - 1);
                let scale = 1000;
                if (pos6 === '6') scale = 10000;
                else if (pos6 === '8') scale = 100000;
                
                // Don't scale count values
                if (['390', '391', '392'].includes(wi)) return num;
                
                return num / scale;
            }

            calculateStats() {
                const points = new Set();
                const heights = [];
                let setupCount = 0;
                
                // Build level runs for better analysis
                this.levelRuns = this.buildLevelRuns();
                this.aggregatedRuns = this.aggregateChangePointRuns();
                
                this.data.forEach(record => {
                    if (record.words['11']) {
                        points.add(record.words['11'].value);
                    }
                    if (record.words['83']) {
                        heights.push(record.words['83'].value);
                    }
                    if (record.type === 'backsight') {
                        setupCount++;
                    }
                });
                
                this.stats.recordCount = this.data.length;
                this.stats.pointCount = points.size;
                this.stats.setupCount = setupCount;
                this.stats.uniquePoints = Array.from(points);
                
                if (heights.length > 0) {
                    const min = Math.min(...heights);
                    const max = Math.max(...heights);
                    this.stats.heightRange = min.toFixed(3) + 'm - ' + max.toFixed(3) + 'm';
                } else {
                    this.stats.heightRange = '‚Äî';
                }
                
                // Detect method
                const methodRecord = this.data.find(r => r.words['41'] && r.words['41'].data.includes('?'));
                if (methodRecord) {
                    const code = methodRecord.words['41'].data;
                    if (code.includes('1')) this.stats.method = 'BF';
                    else if (code.includes('2')) this.stats.method = 'BFFB';
                    else this.stats.method = 'Unknown';
                } else {
                    this.stats.method = '‚Äî';
                }
            }

            buildLevelRuns() {
                const runs = [];
                let currentRun = null;
                let setupNumber = 0;
                
                this.data.forEach((record, index) => {
                    record.setupNumber = setupNumber;
                    
                    if (record.type === 'backsight') {
                        if (currentRun) {
                            runs.push(currentRun);
                        }
                        setupNumber++;
                        currentRun = {
                            setupNumber: setupNumber,
                            backsight: record,
                            foresights: [],
                            intermediates: []
                        };
                        record.setupNumber = setupNumber;
                    } else if (currentRun) {
                        if (record.type === 'foresight') {
                            currentRun.foresights.push(record);
                            record.setupNumber = setupNumber;
                        } else if (record.type === 'intermediate') {
                            currentRun.intermediates.push(record);
                            record.setupNumber = setupNumber;
                        }
                    }
                });
                
                if (currentRun) {
                    runs.push(currentRun);
                }
                
                return runs;
            }

            isChangePoint(pointId) {
                if (!pointId) return false;
                
                const method = this.processingOptions.changePointMethod;
                const prefix = this.processingOptions.changePointPrefix.toUpperCase();
                const upperPointId = pointId.toUpperCase();
                
                switch (method) {
                    case 'prefix':
                        return upperPointId.startsWith(prefix);
                        
                    case 'numeric':
                        // Check if point ID is purely numeric and within range
                        if (!/^\d+$/.test(pointId)) return false;
                        const num = parseInt(pointId);
                        return num >= this.processingOptions.numericMin && 
                               num <= this.processingOptions.numericMax;
                        
                    case 'both':
                        // Check prefix method first
                        if (upperPointId.startsWith(prefix)) return true;
                        
                        // Then check numeric method
                        if (!/^\d+$/.test(pointId)) return false;
                        const numBoth = parseInt(pointId);
                        return numBoth >= this.processingOptions.numericMin && 
                               numBoth <= this.processingOptions.numericMax;
                        
                    default:
                        return false;
                }
            }

            aggregateChangePointRuns() {
                if (!this.processingOptions.aggregateCP) {
                    return this.levelRuns;
                }

                const aggregatedRuns = [];
                const prefix = this.processingOptions.changePointPrefix.toUpperCase();
                
                // Security: Prevent infinite loops with maximum iterations
                const maxIterations = this.levelRuns.length * 2;
                let iterations = 0;
                
                // Group consecutive runs that form a change point sequence
                let i = 0;
                while (i < this.levelRuns.length && iterations < maxIterations) {
                    iterations++;
                    
                    const currentRun = this.levelRuns[i];
                    
                    // Check if this starts a change point sequence
                    const bsPoint = currentRun.backsight.words['11'] ? currentRun.backsight.words['11'].value.toUpperCase() : '';
                    const isStartOfSequence = !bsPoint.startsWith(prefix) && 
                        currentRun.foresights.some(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                            return fsPoint.startsWith(prefix);
                        });
                    
                    if (!isStartOfSequence) {
                        // Not a change point sequence, add as-is
                        aggregatedRuns.push(currentRun);
                        i++;
                        continue;
                    }
                    
                    // Find the end of the change point sequence
                    let sequenceRuns = [currentRun];
                    let j = i + 1;
                    
                    while (j < this.levelRuns.length && iterations < maxIterations) {
                        iterations++;
                        const nextRun = this.levelRuns[j];
                        const nextBsPoint = nextRun.backsight.words['11'] ? nextRun.backsight.words['11'].value.toUpperCase() : '';
                        
                        if (nextBsPoint.startsWith(prefix)) {
                            sequenceRuns.push(nextRun);
                            j++;
                        } else {
                            break;
                        }
                    }
                    
                    // Create aggregated run from the sequence
                    const firstRun = sequenceRuns[0];
                    const lastRun = sequenceRuns[sequenceRuns.length - 1];
                    
                    // Find the final non-CP foresight
                    const finalForesight = lastRun.foresights.find(fs => {
                        const fsPoint = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                        return !fsPoint.startsWith(prefix);
                    });
                    
                    if (finalForesight) {
                        // Calculate total distance and height difference across all runs
                        let totalDistance = 0;
                        let totalHeightDiff = 0;
                        let changePointCount = 0;
                        
                        sequenceRuns.forEach(run => {
                            const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                            const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                            totalDistance += bsDistance;
                            
                            run.foresights.forEach(fs => {
                                const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                                const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                                const fsPoint = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                                
                                totalDistance += fsDistance;
                                totalHeightDiff += (bsReading - fsReading);
                                
                                if (fsPoint.startsWith(prefix)) {
                                    changePointCount++;
                                }
                            });
                        });
                        
                        const aggregatedRun = {
                            setupNumber: firstRun.setupNumber,
                            backsight: firstRun.backsight,
                            foresights: [finalForesight],
                            intermediates: [],
                            totalTurns: changePointCount + 1,
                            totalDistance: totalDistance,
                            totalHeightDiff: totalHeightDiff,
                            isAggregated: true
                        };
                        
                        aggregatedRuns.push(aggregatedRun);
                    } else {
                        // No final non-CP point found, add runs as-is
                        sequenceRuns.forEach(run => aggregatedRuns.push(run));
                    }
                    
                    i = j;
                }

                if (iterations >= maxIterations) {
                    console.warn('Aggregation loop safety limit reached');
                }

                return aggregatedRuns;
            }

            processChangePointSequence(run, aggregatedRuns, prefix) {
                // Find the sequence: Named BS ‚Üí CPs ‚Üí Named FS
                const backsight = run.backsight;
                const bsPointId = backsight.words['11'] ? backsight.words['11'].value.toUpperCase() : '';
                
                // Skip if backsight is itself a change point
                if (bsPointId.startsWith(prefix)) {
                    aggregatedRuns.push(run);
                    return;
                }

                // Find the final foresight (non-change point)
                const finalForesight = run.foresights.find(fs => {
                    const fsPointId = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                    return !fsPointId.startsWith(prefix);
                });

                if (!finalForesight) {
                    // No named foresight found, use as-is
                    aggregatedRuns.push(run);
                    return;
                }

                // Count turns: BS ‚Üí CP1 ‚Üí CP2 ‚Üí ... ‚Üí FS
                const changePoints = run.foresights.filter(fs => {
                    const fsPointId = fs.words['11'] ? fs.words['11'].value.toUpperCase() : '';
                    return fsPointId.startsWith(prefix);
                });

                const totalTurns = changePoints.length + 1; // CPs + final turn to named point

                // Create aggregated observation
                const aggregatedRun = {
                    setupNumber: run.setupNumber,
                    backsight: backsight,
                    foresights: [finalForesight],
                    intermediates: run.intermediates.filter(is => {
                        const isPointId = is.words['11'] ? is.words['11'].value.toUpperCase() : '';
                        return !isPointId.startsWith(prefix);
                    }),
                    changePoints: changePoints,
                    totalTurns: totalTurns,
                    isAggregated: true
                };

                aggregatedRuns.push(aggregatedRun);
            }

            generateReport() {
                let report = 'LEVELING REPORT\n';
                report += '================\n\n';
                report += 'Generated: ' + new Date().toLocaleString() + '\n';
                report += 'Records: ' + this.stats.recordCount + '\n';
                report += 'Points: ' + this.stats.pointCount + '\n';
                report += 'Setups: ' + this.stats.setupCount + '\n';
                report += 'Method: ' + this.stats.method + '\n';
                report += 'Height Range: ' + this.stats.heightRange + '\n';
                
                // Add processing options info
                if (this.processingOptions.aggregateCP) {
                    let cpInfo = 'Change Point Processing: Enabled (';
                    if (this.processingOptions.changePointMethod === 'prefix') {
                        cpInfo += 'Prefix: ' + this.processingOptions.changePointPrefix;
                    } else if (this.processingOptions.changePointMethod === 'numeric') {
                        cpInfo += 'Numeric: ' + this.processingOptions.numericMin + '-' + this.processingOptions.numericMax;
                    } else {
                        cpInfo += 'Both: ' + this.processingOptions.changePointPrefix + ' and ' + this.processingOptions.numericMin + '-' + this.processingOptions.numericMax;
                    }
                    cpInfo += ')\n';
                    report += cpInfo;
                }
                
                report += '\n';
                
                report += 'POINT          TYPE          READING       DISTANCE      HEIGHT        SETUP\n';
                report += '-----------------------------------------------------------------------\n';
                
                this.data.forEach(record => {
                    const point = record.words['11'] ? record.words['11'].value : '';
                    const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                    let height = '';
                    const setup = record.setupNumber || '';
                    
                    // Use adjusted elevation if available
                    if (record.words['83']) {
                        height = record.words['83'].value.toFixed(4);
                    }
                    
                    let reading = '';
                    if (record.words['330']) reading = record.words['330'].value.toFixed(5);
                    else if (record.words['331']) reading = record.words['331'].value.toFixed(5);
                    else if (record.words['332']) reading = record.words['332'].value.toFixed(5);
                    else if (record.words['333']) reading = record.words['333'].value.toFixed(5);
                    
                    if (point || reading || distance || height) {
                        report += point.padEnd(14) + ' ';
                        report += record.type.padEnd(13) + ' ';
                        report += reading.padStart(13) + ' ';
                        report += distance.padStart(13) + ' ';
                        report += height.padStart(13) + ' ';
                        report += setup.toString().padStart(5) + '\n';
                    }
                });
                
                // Add level run summary
                if (this.levelRuns && this.levelRuns.length > 0) {
                    report += '\nLEVEL RUN SUMMARY\n';
                    report += '==================\n\n';
                    
                    const runsToShow = this.processingOptions.aggregateCP ? this.aggregatedRuns : this.levelRuns;
                    
                    runsToShow.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value.toFixed(5) : '';
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value.toFixed(3) : '';
                        
                        report += 'Setup ' + run.setupNumber + ':\n';
                        report += '  BS: ' + bsPoint + ' (' + bsReading + 'm @ ' + bsDistance + 'm)\n';
                        
                        // Show change point details if enabled
                        if (this.processingOptions.showCPDetails && run.changePoints && run.changePoints.length > 0) {
                            run.changePoints.forEach(cp => {
                                const cpPoint = cp.words['11'] ? cp.words['11'].value : '';
                                const cpReading = cp.words['332'] ? cp.words['332'].value.toFixed(5) : '';
                                const cpDistance = cp.words['32'] ? cp.words['32'].value.toFixed(3) : '';
                                report += '  CP: ' + cpPoint + ' (' + cpReading + 'm @ ' + cpDistance + 'm)\n';
                            });
                        }
                        
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value.toFixed(5) : '';
                            const fsDistance = fs.words['32'] ? fs.words['32'].value.toFixed(3) : '';
                            const heightDiff = run.backsight.words['331'] && fs.words['332'] ? 
                                (run.backsight.words['331'].value - fs.words['332'].value).toFixed(5) : '';
                            
                            let fsLine = '  FS: ' + fsPoint + ' (' + fsReading + 'm @ ' + fsDistance + 'm) Œîh=' + heightDiff + 'm';
                            
                            // Add turn count if enabled and aggregated
                            if (this.processingOptions.includeTurnCount && run.isAggregated && run.totalTurns > 1) {
                                fsLine += ' [' + run.totalTurns + ' turns]';
                            }
                            
                            report += fsLine + '\n';
                        });
                        
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isReading = is.words['333'] ? is.words['333'].value.toFixed(5) : '';
                            const isDistance = is.words['32'] ? is.words['32'].value.toFixed(3) : '';
                            
                            report += '  IS: ' + isPoint + ' (' + isReading + 'm @ ' + isDistance + 'm)\n';
                        });
                        
                        report += '\n';
                    });
                }
                
                return report;
            }

            exportStarNet() {
                let output = '# GSI Level Data Export\n';
                output += '# Generated: ' + new Date().toLocaleString() + '\n';
                output += '# Method: ' + this.stats.method + '\n';
                output += '# Setups: ' + this.stats.setupCount + '\n\n';
                
                // Units and settings
                output += '.UNITS METERS\n';
                output += '#.SEPARATOR /\n\n';
                
                // Find first point with height as benchmark (commented out by default)
                const firstPoint = this.data.find(r => r.words['11'] && r.words['83']);
                if (firstPoint) {
                    output += '# Fixed elevation - uncomment if needed:\n';
                    output += '#E ' + firstPoint.words['11'].value + ' ' + firstPoint.words['83'].value.toFixed(4) + '\n\n';
                }
                
                // Process level runs to create proper leveling observations
                const runsToProcess = (this.processingOptions.aggregateCP && this.aggregatedRuns) ? 
                    this.aggregatedRuns : this.levelRuns;
                
                if (runsToProcess && runsToProcess.length > 0) {
                    runsToProcess.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                        
                        // Create leveling observations for each foresight
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                            const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                            
                            if (bsPoint && fsPoint) {
                                let heightDiff, totalDistance;
                                
                                if (run.isAggregated) {
                                    // Use pre-calculated values for aggregated runs
                                    heightDiff = run.totalHeightDiff;
                                    totalDistance = run.totalDistance;
                                } else {
                                    // Calculate normally for non-aggregated runs
                                    heightDiff = bsReading - fsReading;
                                    totalDistance = bsDistance + fsDistance;
                                }
                                
                                // Add setup info as comment
                                let comment = '# Setup ' + run.setupNumber + ': ';
                                
                                if (run.isAggregated && run.totalTurns > 1) {
                                    comment += 'Aggregated ' + run.totalTurns + ' turns, Total distance=' + totalDistance.toFixed(3) + 'm';
                                } else {
                                    comment += 'BS=' + bsDistance.toFixed(3) + 'm, FS=' + fsDistance.toFixed(3) + 'm';
                                }
                                
                                output += comment + '\n';
                                
                                // StarNet leveling observation: L From-To ElevDiff Distance
                                output += 'L ' + bsPoint + '-' + fsPoint + ' ' + heightDiff.toFixed(5) + ' ' + totalDistance.toFixed(3) + '\n';
                            }
                        });
                        
                        // Create height observations for intermediate sights
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isHeight = is.words['83'] ? is.words['83'].value : null;
                            
                            if (isPoint && isHeight !== null) {
                                output += '# Intermediate sight - uncomment if needed:\n';
                                output += '#E ' + isPoint + ' ' + isHeight.toFixed(4) + '\n';
                            }
                        });
                        
                        output += '\n';
                    });
                } else {
                    // Fallback: simple height differences
                    let lastPoint = null;
                    let lastHeight = null;
                    let lastDistance = 0;
                    
                    this.data.forEach(record => {
                        if (record.words['11'] && record.words['83']) {
                            const point = record.words['11'].value;
                            const height = record.words['83'].value;
                            const distance = record.words['32'] ? record.words['32'].value : 0;
                            
                            if (lastPoint && lastHeight !== null) {
                                const heightDiff = height - lastHeight;
                                const totalDist = lastDistance + distance;
                                
                                output += 'L ' + lastPoint + '-' + point + ' ' + heightDiff.toFixed(5) + ' ' + totalDist.toFixed(3) + '\n';
                            }
                            
                            if (record.type === 'foresight') {
                                lastPoint = point;
                                lastHeight = height;
                                lastDistance = distance;
                            }
                        }
                    });
                }
                
                output += '\n# End of level data\n';
                return output;
            }

            exportCSV() {
                let csv = 'Point,Type,Reading,Distance,Height,Setup,Line\n';
                
                this.data.forEach(record => {
                    const point = record.words['11'] ? record.words['11'].value : '';
                    const distance = record.words['32'] ? record.words['32'].value : '';
                    const height = record.words['83'] ? record.words['83'].value : '';
                    const setup = record.setupNumber || '';
                    
                    let reading = '';
                    if (record.words['330']) reading = record.words['330'].value;
                    else if (record.words['331']) reading = record.words['331'].value;
                    else if (record.words['332']) reading = record.words['332'].value;
                    else if (record.words['333']) reading = record.words['333'].value;
                    
                    csv += '"' + point + '","' + record.type + '","' + reading + '","' + distance + '","' + height + '","' + setup + '","' + record.lineNumber + '"\n';
                });
                
                return csv;
            }
        }

        // App state
        let parser = new GSIParser();
        let currentOutput = '';
        let currentExtension = 'txt';

        // DOM elements
        const themeBtn = document.getElementById('themeBtn');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const statsSection = document.getElementById('statsSection');
        const actionsSection = document.getElementById('actionsSection');
        const previewSection = document.getElementById('previewSection');
        const outputSection = document.getElementById('outputSection');
        const dataTable = document.getElementById('dataTable');
        const outputArea = document.getElementById('outputArea');
        const recordCount = document.getElementById('recordCount');
        const pointCount = document.getElementById('pointCount');
        const methodType = document.getElementById('methodType');
        const heightRange = document.getElementById('heightRange');
        const reportBtn = document.getElementById('reportBtn');
        const starnetBtn = document.getElementById('starnetBtn');
        const csvBtn = document.getElementById('csvBtn');
        const advancedBtn = document.getElementById('advancedBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const copyBtn = document.getElementById('copyBtn');

        // Advanced section elements
        const advancedSection = document.getElementById('advancedSection');
        const advancedToggle = document.getElementById('advancedToggle');
        const applyAdvanced = document.getElementById('applyAdvanced');
        const aggregateCP = document.getElementById('aggregateCP');
        const changePointPrefix = document.getElementById('changePointPrefix');
        const includeTurnCount = document.getElementById('includeTurnCount');
        const showCPDetails = document.getElementById('showCPDetails');

        // Change point method elements
        const prefixSettings = document.getElementById('prefixSettings');
        const numericSettings = document.getElementById('numericSettings');
        const numericMin = document.getElementById('numericMin');
        const numericMax = document.getElementById('numericMax');


        // Theme toggle
        themeBtn.addEventListener('click', function() {
            const current = document.documentElement.getAttribute('data-theme');
            const newTheme = current === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        });

        // Load saved theme
        const savedTheme = localStorage.getItem('theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);

        // File upload
        uploadArea.addEventListener('click', function() {
            fileInput.click();
        });

        uploadArea.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', function(e) {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                processFile(e.dataTransfer.files[0]);
            }
        });

        fileInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                processFile(e.target.files[0]);
            }
        });

        // Advanced options event listeners
        advancedBtn.addEventListener('click', function() {
            advancedSection.classList.toggle('hidden');
            advancedBtn.textContent = advancedSection.classList.contains('hidden') ? '‚öôÔ∏è Advanced' : '‚öôÔ∏è Hide Advanced';
        });

        advancedToggle.addEventListener('click', function() {
            advancedSection.classList.add('hidden');
            advancedBtn.textContent = '‚öôÔ∏è Advanced';
        });

        // Change point method toggle handlers
        document.querySelectorAll('input[name="changePointMethod"]').forEach(radio => {
            radio.addEventListener('change', function() {
                toggleChangePointSettings(this.value);
            });
        });

        function toggleChangePointSettings(method) {
            switch (method) {
                case 'prefix':
                    prefixSettings.style.display = 'block';
                    numericSettings.style.display = 'none';
                    break;
                case 'numeric':
                    prefixSettings.style.display = 'none';
                    numericSettings.style.display = 'block';
                    break;
                case 'both':
                    prefixSettings.style.display = 'block';
                    numericSettings.style.display = 'block';
                    break;
            }
        }

        // FIXED - Complete applyAdvanced event listener
        applyAdvanced.addEventListener('click', function() {
            
            // Get change point method settings
            const changePointMethod = document.querySelector('input[name="changePointMethod"]:checked').value;
            
            // Update processing options
            const newOptions = {
                aggregateCP: aggregateCP.checked,
                changePointPrefix: changePointPrefix.value || 'CP',
                changePointMethod: changePointMethod,
                numericMin: parseInt(numericMin.value) || 1,
                numericMax: parseInt(numericMax.value) || 999,
                includeTurnCount: includeTurnCount.checked,
                showCPDetails: showCPDetails.checked
            };
            
            
            try {
                parser.updateProcessingOptions(newOptions);
                showStatus('‚úì Data reprocessed with new options', 'success');
                updateUI();
                
                // Clear any existing output
                outputSection.classList.add('hidden');
                
                // Subtle acknowledgement in the apply button
                applyAdvanced.textContent = '‚úì Applied';
                applyAdvanced.style.background = 'var(--accent)';
                applyAdvanced.style.color = 'var(--bg)';
                
                setTimeout(function() {
                    applyAdvanced.textContent = 'Apply & Reprocess';
                    applyAdvanced.style.background = '';
                    applyAdvanced.style.color = '';
                }, 2000);
                
            } catch (error) {
                console.error('Reprocessing error:', error);
                showStatus('‚úó Error reprocessing: ' + error.message, 'error');
            }
        });

        // Security constants
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit
        const MAX_RECORDS = 500000; // Increased for larger surveys
        const MAX_LINE_LENGTH = 1000; // Reduced but still reasonable for GSI lines
        const PROCESSING_TIMEOUT = 60000; // Increased to 60 seconds

        function processFile(file) {
            // Security check: File size
            if (file.size > MAX_FILE_SIZE) {
                showStatus('‚úó File too large. Maximum size is 50MB.', 'error');
                return;
            }

            // Security check: File type
            const allowedExtensions = ['.gsi', '.txt', '.dat', '.raw'];
            const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
            if (!allowedExtensions.includes(fileExtension)) {
                showStatus('‚úó Invalid file type. Only GSI, TXT, DAT, and RAW files are allowed.', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // Set processing timeout
                    const timeoutId = setTimeout(() => {
                        throw new Error('File processing timeout - file may be malformed');
                    }, PROCESSING_TIMEOUT);

                    const result = parser.parse(e.target.result);
                    clearTimeout(timeoutId);
                    
                    showStatus('‚úì Parsed ' + parser.data.length + ' records', 'success');
                    updateUI();
                } catch (error) {
                    showStatus('‚úó Error: ' + escapeHtml(error.message), 'error');
                    console.error('Parsing error:', error);
                }
            };
            
            reader.onerror = function() {
                showStatus('‚úó Error reading file', 'error');
            };
            
            reader.readAsText(file);
        }

        // HTML escaping function to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
            status.classList.remove('hidden');
        }

        function updateUI() {
            // Update stats
            recordCount.textContent = parser.stats.recordCount;
            pointCount.textContent = parser.stats.pointCount;
            methodType.textContent = parser.stats.method;
            heightRange.textContent = parser.stats.heightRange;

            // Update table with XSS protection
            dataTable.innerHTML = '';
            parser.data.slice(0, 20).forEach(function(record) {
                if (record.type === 'method_code') return; // Skip method codes
                
                const row = document.createElement('tr');
                const point = record.words['11'] ? escapeHtml(record.words['11'].value) : '';
                const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                const height = record.words['83'] ? record.words['83'].value.toFixed(4) : '';
                
                let reading = '';
                if (record.words['330']) reading = record.words['330'].value.toFixed(5);
                else if (record.words['331']) reading = record.words['331'].value.toFixed(5);
                else if (record.words['332']) reading = record.words['332'].value.toFixed(5);
                else if (record.words['333']) reading = record.words['333'].value.toFixed(5);
                
                // Use textContent instead of innerHTML to prevent XSS
                const pointCell = document.createElement('td');
                pointCell.textContent = record.words['11'] ? record.words['11'].value : '';
                
                const typeCell = document.createElement('td');
                const typeBadge = document.createElement('span');
                typeBadge.className = 'type-badge type-' + record.type;
                typeBadge.textContent = record.type;
                typeCell.appendChild(typeBadge);
                
                const readingCell = document.createElement('td');
                readingCell.textContent = reading;
                
                const distanceCell = document.createElement('td');
                distanceCell.textContent = distance;
                
                const heightCell = document.createElement('td');
                heightCell.textContent = height;
                
                const setupCell = document.createElement('td');
                setupCell.textContent = record.setupNumber || '';
                
                row.appendChild(pointCell);
                row.appendChild(typeCell);
                row.appendChild(readingCell);
                row.appendChild(distanceCell);
                row.appendChild(heightCell);
                row.appendChild(setupCell);
                
                dataTable.appendChild(row);
            });

            // Show sections
            statsSection.classList.remove('hidden');
            actionsSection.classList.remove('hidden');
            previewSection.classList.remove('hidden');
        }

        function showOutput(content) {
            currentOutput = content;
            outputArea.textContent = content;
            outputSection.classList.remove('hidden');
        }

        // Button handlers
        reportBtn.addEventListener('click', function() {
            showOutput(parser.generateReport());
        });

        starnetBtn.addEventListener('click', function() {
            showOutput(parser.exportStarNet());
        });

        csvBtn.addEventListener('click', function() {
            showOutput(parser.exportCSV());
        });

        downloadBtn.addEventListener('click', function() {
            const blob = new Blob([currentOutput], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gsi_export_' + new Date().toISOString().slice(0, 10) + '.txt';
            a.click();
            URL.revokeObjectURL(url);
        });

        copyBtn.addEventListener('click', function() {
            navigator.clipboard.writeText(currentOutput).then(function() {
                copyBtn.textContent = '‚úì Copied';
                setTimeout(function() {
                    copyBtn.textContent = 'üìã Copy';
                }, 2000);
            });
        });

    </script>
</body>
</html>