<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSI Level Parser</title>
    <style>
        :root {
            --bg: #0f0f0f;
            --surface: #1a1a1a;
            --surface-light: #2a2a2a;
            --text: #ffffff;
            --text-dim: #888888;
            --accent: #00ff88;
            --accent-dim: #00cc6a;
            --border: #333333;
        }

        [data-theme="light"] {
            --bg: #f5f5f5;
            --surface: #ffffff;
            --surface-light: #f8f9fa;
            --text: #1a1a1a;
            --text-dim: #666666;
            --accent: #0066cc;
            --accent-dim: #0052a3;
            --border: #e0e0e0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .theme-btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
        }

        .theme-btn:hover {
            background: var(--surface-light);
        }

        .upload-area {
            background: var(--surface);
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .upload-area.dragover {
            border-color: var(--accent);
            background: var(--surface-light);
        }

        .file-input { display: none; }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            margin-top: 5px;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: var(--accent);
            color: var(--bg);
        }
        
        .btn.status-action {
            padding: 6px 12px;
            font-size: 12px;
            margin-right: 8px;
        }

        .btn.primary {
            background: var(--accent);
            color: var(--bg);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: var(--surface);
            color: var(--text);
        }

        .data-table {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .table-header {
            background: var(--surface-light);
            padding: 15px 20px;
            font-weight: bold;
            border-bottom: 1px solid var(--border);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            font-family: inherit;
            font-size: 13px;
        }

        th {
            background: var(--surface-light);
            font-weight: bold;
            color: var(--text-dim);
        }

        tr:hover {
            background: var(--surface-light);
        }

        .output {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            font-family: inherit;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            margin-bottom: 15px;
        }

        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 14px;
        }

        .status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        .status.error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff4444;
            color: #ff4444;
        }

        .status.warning {
            background: rgba(255, 165, 0, 0.1);
            border: 1px solid #ffa500;
            color: #ffa500;
        }
        
        .status.info {
            background: rgba(0, 123, 255, 0.1);
            border: 1px solid #007bff;
            color: #80bfff;
        }

        .hidden {
            display: none;
        }

        .section { margin-bottom: 30px; }

        .type-badge {
            background: var(--surface-light);
            color: var(--text-dim);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            text-transform: uppercase;
        }

        .type-backsight { background: rgba(0, 255, 136, 0.2); color: var(--accent); }
        .type-foresight { background: rgba(255, 165, 0, 0.2); color: #ffa500; }
        .type-intermediate { background: rgba(0, 123, 255, 0.2); color: #007bff; }

        .section-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: var(--text);
        }

        .advanced-content {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 25px;
        }

        .advanced-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 25px;
        }

        .advanced-group h4 {
            margin-bottom: 15px;
            color: var(--text);
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"],
        .checkbox-label input[type="radio"] {
            width: 16px;
            height: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text);
        }

        .form-input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg);
            color: var(--text);
            font-family: inherit;
        }

        .help-text {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 15px;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .advanced-grid {
                grid-template-columns: 1fr;
            }
            
            .actions {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">‚ö° GSI.PARSER</div>
            <div class="header-controls">
                <button class="btn" id="aboutBtn" aria-label="About this tool">‚ÑπÔ∏è About</button>
                <button class="theme-btn" id="themeBtn" aria-label="Toggle theme">üåì</button>
            </div>
        </div>

        <div class="section">
            <div class="upload-area" id="uploadArea" role="button" tabindex="0">
                <div style="font-size: 36px; margin-bottom: 10px;">üìÅ</div>
                <div>Drop GSI file here or click to select</div>
                <div style="font-size: 12px; color: var(--text-dim); margin-top: 5px;">
                    Supports .gsi, .txt, and other level data formats
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".gsi,.txt,.dat,.raw" aria-label="Select GSI file">
            </div>
            <div id="status" class="status hidden" role="alert"></div>
            <div id="formatStatus" class="status hidden" role="status"></div>
        </div>

        <div class="section hidden" id="aboutSection">
            <div class="section-title">
                ‚ÑπÔ∏è About GSI.PARSER
                <button class="btn" id="aboutToggle">Hide</button>
            </div>
            
            <div class="advanced-content">
                <div class="advanced-grid">
                    <div class="advanced-group">
                        <h4>üéØ Features</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li>Parse GSI format levelling data with intelligent format detection</li>
                            <li>Aggregate change point readings for cleaner analysis</li>
                            <li>Export to multiple formats: Reports, StarNet, CSV</li>
                            <li>Advanced processing options for different survey methods <i>coming soon!</i></li>
                            <li>Real-time data validation and error reporting <i>coming soon!</i></li>
                            <br>
                        </ul>

                        <h4>üìÅ Supported Formats</h4>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li><strong>.gsi</strong> - Standard GSI format files</li>
                            <li><strong>.txt</strong> - Text-based GSI data</li>
                           
                        </ul>
                    </div>
                    
                    <div class="advanced-group">
                        <h4>‚öôÔ∏è How to Use</h4>
                        <ol style="margin: 0; padding-left: 20px;">
                            <li>Upload your GSI file using drag & drop or file selection</li>
                            <li>Review the parsed data in the preview table</li>
                            <li>Configure advanced options if needed (change points, output preferences)</li>
                            <li>Export your data in the desired format</li>
                            <br>
                        </ol>

                        <h4>üîß Technical Notes</h4>
                        <p style="margin: 0;">This parser is optimised for levelling data and supports both GSI-8 and GSI-16 formats. Processing of TPS and other forms of .GSI data are in development..</p>

                        <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border); font-size: 12px; color: var(--text-dim);">
                            <strong>Version:</strong> 2025.1 ‚Ä¢ <strong>Created by:</strong> B Brewster
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="statsSection">
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="recordCount">0</div>
                    <div class="stat-label">Records</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="pointCount">0</div>
                    <div class="stat-label">Points</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="methodType">‚Äî</div>
                    <div class="stat-label">Method</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="heightRange">‚Äî</div>
                    <div class="stat-label">Height Range</div>
                </div>
            </div>
        </div>

        <div class="section hidden" id="actionsSection">
            <div class="actions">
                <button class="btn" id="reportBtn">üìÑ Report</button>
                <button class="btn" id="starnetBtn">‚≠ê StarNet</button>
                <button class="btn" id="csvBtn">üìä CSV</button>
                <button class="btn" id="advancedBtn">‚öôÔ∏è Advanced</button>
            </div>
        </div>

        <div class="section hidden" id="advancedSection">
            <div class="section-title">
                ‚öôÔ∏è Advanced Processing Options
                <button class="btn" id="advancedToggle">Hide</button>
            </div>
            
            <div class="advanced-content">
                <div class="advanced-grid">
                    <div class="advanced-group">
                        <h4>Change Point Processing</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="aggregateCP" checked>
                            <span>Aggregate change point readings</span>
                        </label>
                        <p class="help-text">
                            Groups readings between named stations through change points
                        </p>
                        
                        <label class="form-label">Change Point Detection Method:</label>
                        <div style="margin-bottom: 15px;">
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="prefix" checked>
                                <span>Text Prefix (e.g., CP, TP, TBM)</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="numeric">
                                <span>Numeric Only (1, 2, 3, 4...)</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="radio" name="changePointMethod" value="both">
                                <span>Both Methods</span>
                            </label>
                        </div>
                        
                        <div id="prefixSettings">
                            <label class="form-label" for="changePointPrefix">Change Point Prefix:</label>
                            <input type="text" id="changePointPrefix" value="CP" placeholder="e.g., CP, TP, TBM" class="form-input">
                        </div>
                        
                        <div id="numericSettings" style="display: none;">
                            <label class="form-label">Numeric Range:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="number" id="numericMin" value="1" min="0" max="999" class="form-input" style="width: 80px;" placeholder="Min">
                                <span>to</span>
                                <input type="number" id="numericMax" value="999" min="1" max="9999" class="form-input" style="width: 80px;" placeholder="Max">
                            </div>
                            <p class="help-text">
                                Point names that are purely numeric within this range will be treated as change points
                            </p>
                        </div>
                    </div>
                    
                    <div class="advanced-group">
                        <h4>Output Options</h4>
                        <label class="checkbox-label">
                            <input type="checkbox" id="includeTurnCount">
                            <span>Include turn count in reports</span>
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showCPDetails">
                            <span>Show change point details</span>
                        </label>
                         <label class="checkbox-label" style="margin-top: 15px;">
                            <input type="checkbox" id="retainCalibration">
                            <span>Retain calibration data in main survey</span>
                        </label>
                        <p class="help-text">
                            If unchecked, detected 2-peg tests will be automatically excluded from results.
                        </p>
                        
                        <button class="btn primary" id="applyAdvanced" style="margin-top: 10px;">
                            <span id="applyText">Apply & Reprocess</span>
                            <div id="applySpinner" class="loading-spinner hidden" style="display: none;"></div>
                        </button>
                    </div>
                </div>
            </div>
        </div>

       <div class="section hidden" id="previewSection">
    <div class="data-table">
        <div class="table-header">
            Data Preview
            <button class="btn" id="toggleViewBtn" style="float: right; padding: 5px 10px; font-size: 12px; display: none;">Show All</button>
        </div>
        <div style="max-height: 400px; overflow-y: auto;">
                    <table>
                        <thead>
                            <tr>
                                <th>Point</th>
                                <th>Type</th>
                                <th>Reading</th>
                                <th>Distance</th>
                                <th>Height</th>
                                <th>Setup</th>
                            </tr>
                        </thead>
                        <tbody id="dataTable"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="section hidden" id="outputSection">
            <div class="output" id="outputArea"></div>
            <div>
                <button class="btn" id="downloadBtn">üíæ Download</button>
                <button class="btn" id="copyBtn">üìã Copy</button>
            </div>
        </div>

        <div style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid var(--border); color: var(--text-dim); font-size: 12px;">
            Created by B Brewster 2025
        </div>
    </div>

    <script>
        // Ko-fi widget - will only work on a live website
        if (window.location.protocol !== 'file:' && window.location.hostname !== 'localhost') {
            const script = document.createElement('script');
            script.src = 'https://storage.ko-fi.com/cdn/scripts/overlay-widget.js';
            script.async = true;
            script.onload = function() {
                setTimeout(function() {
                    if (typeof kofiWidgetOverlay !== 'undefined') {
                        try {
                            kofiWidgetOverlay.draw('bbrewster', {
                                'type': 'floating-chat',
                                'floating-chat.donateButton.text': '',
                                'floating-chat.donateButton.background-color': '#ffffff',
                                'floating-chat.donateButton.text-color': '#323842'
                            });
                        } catch (error) {
                            console.warn('Ko-fi widget initialization failed:', error);
                        }
                    }
                }, 100);
            };
            script.onerror = function() {
                console.log('Ko-fi widget unavailable (normal for local/development sites)');
            };
            document.head.appendChild(script);
        }
    </script>
    
    <script>
        'use strict';

        // Security constants
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB limit
        const MAX_RECORDS = 500000;
        const MAX_LINE_LENGTH = 1000;
        const PROCESSING_TIMEOUT = 60000;
        const MAX_PREVIEW_ROWS = 1000; // Safety limit for "Show All"

        class GSIParser {
            constructor() {
                this.rawData = '';
                this.data = [];
                this.fullData = []; // Store the original full data set
                this.stats = {};
                this.levelRuns = [];
                this.aggregatedRuns = [];
                this.calibrationInfo = {};
                this.processingOptions = {
                    aggregateCP: true,
                    changePointPrefix: 'CP',
                    changePointMethod: 'prefix',
                    numericMin: 1,
                    numericMax: 999,
                    includeTurnCount: false,
                    showCPDetails: false,
                    retainCalibrationData: false
                };
            }

            parse(text) {
                if (text.length > MAX_FILE_SIZE) {
                    throw new Error('Input text too large');
                }

                this.rawData = text;
                this.data = []; // Reset data
                const lines = text.split('\n');
                
                if (lines.length > MAX_RECORDS) {
                    throw new Error(`Too many lines. Maximum ${MAX_RECORDS} lines allowed.`);
                }
                
                // Perform a preliminary format check on the raw lines
                const formatAnalysis = this.analyzeGSIFormat(lines);
                this.displayFormatWarnings(formatAnalysis);
                
                let processedRecords = 0;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    if (line.length > MAX_LINE_LENGTH) {
                        console.warn(`Skipping excessively long line ${i + 1}`);
                        continue;
                    }
                    
                    if (processedRecords >= MAX_RECORDS) {
                        console.warn(`Reached maximum record limit of ${MAX_RECORDS}`);
                        break;
                    }
                    
                    const record = this.parseLine(line);
                    if (record) {
                        record.lineNumber = i + 1;
                        this.data.push(record);
                        processedRecords++;
                    }
                }
                
                this.fullData = [...this.data]; // Keep a copy of the full dataset
                this.processAndAnalyze(); // Separate calibration data and calculate stats
                
                return this.data; // Return the main survey data
            }
            
            processAndAnalyze() {
                // Phase 1: Detect calibration data using the full dataset
                const allRuns = this.buildLevelRuns(this.fullData);
                this.calibrationInfo = this.identifyCalibrationData(allRuns);

                this.data = [...this.fullData]; // Start with the full dataset

                // Phase 2: Decide whether to filter based on detection and options
                if (this.calibrationInfo.isCalibration && !this.processingOptions.retainCalibrationData) {
                    // We have a calibration and the user wants to separate it
                    this.displayCalibrationWarning(this.calibrationInfo);

                    const endLineMatch = this.calibrationInfo.recordRange.match(/to\s(\d+)/);
                    if (endLineMatch && endLineMatch[1]) {
                        const endLine = parseInt(endLineMatch[1]);
                        const calibrationEndIndex = this.fullData.findIndex(rec => rec.lineNumber === endLine);

                        if (calibrationEndIndex !== -1) {
                            // Find the first record *after* the calibration that has a '83' (height) value.
                            const mainDataStartIndex = this.fullData.findIndex((rec, index) => 
                                index > calibrationEndIndex && rec.words['83']
                            );
                            
                            if (mainDataStartIndex !== -1) {
                                // Truncate the working `data` array to exclude calibration and start at the first TBM
                                this.data = this.fullData.slice(mainDataStartIndex);
                                showStatus(`‚úì Parsed ${this.fullData.length} records. Calibration test excluded. Processing ${this.data.length} main survey records.`, 'success');
                            } else {
                                this.data = []; // No main survey data found after calibration
                                showStatus(`‚úì Parsed ${this.fullData.length} records. Calibration test found, but no subsequent survey data detected.`, 'warning');
                            }
                        }
                    }
                } else {
                     // No calibration, or user wants to keep it. Use full dataset.
                    if (this.calibrationInfo.isCalibration) {
                         this.showFormatStatus('‚ÑπÔ∏è Calibration data detected and included in the main survey as per settings.', 'info');
                    } else {
                        // Clear any previous format warnings if no new ones are generated
                         document.getElementById('formatStatus').classList.add('hidden');
                    }
                }

                // Phase 3: Process the final selected dataset (either full or main)
                this.calculateStatsForCurrentData();
            }

            calculateStatsForCurrentData() {
                const points = new Set();
                const heights = [];
                
                // Re-build runs and stats using only the main survey data
                this.levelRuns = this.buildLevelRuns(this.data); 
                this.aggregatedRuns = this.aggregateChangePointRuns();
                
                this.data.forEach(record => {
                    if (record.words['11']) {
                        points.add(record.words['11'].value);
                    }
                    if (record.words['83']) {
                        heights.push(record.words['83'].value);
                    }
                });
                
                this.stats = {
                    recordCount: this.data.length,
                    pointCount: points.size,
                    setupCount: this.levelRuns.length,
                    uniquePoints: Array.from(points),
                    heightRange: heights.length > 0 ? 
                        `${Math.min(...heights).toFixed(3)}m - ${Math.max(...heights).toFixed(3)}m` : '‚Äî',
                    method: this.detectMethod()
                };
            }


            analyzeGSIFormat(lines) {
                const analysis = {
                    totalLines: lines.length,
                    validGSILines: 0,
                    invalidLines: [],
                    formatType: 'unknown',
                    isTPS: false,
                    hasLevelingData: false,
                    hasCoordinateData: false,
                    wordCounts: {},
                    errors: [],
                    warnings: []
                };

                const maxSampleSize = Math.min(50, lines.length);

                for (let i = 0; i < maxSampleSize; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const lineAnalysis = this.analyzeGSILine(line, i + 1);
                    
                    if (lineAnalysis.isValid) {
                        analysis.validGSILines++;
                        
                        lineAnalysis.wordIds.forEach(wi => {
                            analysis.wordCounts[wi] = (analysis.wordCounts[wi] || 0) + 1;
                        });
                        
                        if (lineAnalysis.hasLevelingWords) analysis.hasLevelingData = true;
                        if (lineAnalysis.hasCoordinateWords) analysis.hasCoordinateData = true;
                        
                    } else {
                        analysis.invalidLines.push({
                            lineNumber: i + 1,
                            content: line.substring(0, 100) + (line.length > 100 ? '...' : ''),
                            issues: lineAnalysis.issues
                        });
                    }
                }

                this.determineGSIFormat(analysis);
                return analysis;
            }

            analyzeGSILine(line, lineNumber) {
                const result = {
                    isValid: false,
                    wordIds: [],
                    hasLevelingWords: false,
                    hasCoordinateWords: false,
                    issues: []
                };

                const words = line.split(/\s+/);
                
                if (words.length === 0) {
                    result.issues.push('Empty line');
                    return result;
                }

                let validWords = 0;
                const levelingWIs = ['331', '332', '333', '330'];
                const coordinateWIs = ['81', '82', '83', '84', '85', '86', '87', '88'];

                for (const word of words) {
                    if (word.length < 8) {
                        result.issues.push(`Word too short: ${word}`);
                        continue;
                    }

                    let wi, isValidStructure = false;
                    
                    if (word.startsWith('*')) {
                        wi = word.substring(1, 3);
                        isValidStructure = /^\*\d{2}[\d\.]{4}[+\-]\d+$/.test(word);
                    } else {
                        if (/^\d{3}\./.test(word)) {
                            wi = word.substring(0, 3);
                            isValidStructure = /^\d{3}\.[\d\.]{2}[+\-]\d+$/.test(word);
                        } else {
                            wi = word.substring(0, 2);
                            isValidStructure = /^\d{2}[\d\.]{4}[+\-]\d+$/.test(word);
                        }
                    }

                    if (isValidStructure && !isNaN(parseInt(wi))) {
                        validWords++;
                        result.wordIds.push(wi);
                        
                        if (levelingWIs.includes(wi)) result.hasLevelingData = true;
                        if (coordinateWIs.includes(wi)) result.hasCoordinateData = true;
                    } else {
                        result.issues.push(`Invalid GSI word structure: ${word.substring(0, 20)}`);
                    }
                }

                result.isValid = validWords > 0;
                return result;
            }

            determineGSIFormat(analysis) {
                const tpsIndicators = ['16', '17', '18', '19', '58', '59', '71', '72', '73', '74', '75', '76'];
                const coordinateWIs = ['81', '82', '83', '84', '85', '86', '87', '88'];
                const levelingWIs = ['331', '332', '333', '330'];

                const hasTpsWords = tpsIndicators.some(wi => analysis.wordCounts[wi] > 0);
                const hasCoordinates = coordinateWIs.some(wi => analysis.wordCounts[wi] > 0);
                const hasLeveling = levelingWIs.some(wi => analysis.wordCounts[wi] > 0);

                if (hasTpsWords || (hasCoordinates && !hasLeveling)) {
                    analysis.isTPS = true;
                    analysis.formatType = 'TPS';
                    analysis.warnings.push('‚ö†Ô∏è TPS (Total Station) GSI detected - This parser is optimised for levelling data');
                } else if (hasLeveling) {
                    analysis.formatType = 'Levelling';
                } else if (hasCoordinates) {
                    analysis.formatType = 'Coordinate';
                    analysis.warnings.push('‚ö†Ô∏è Coordinate data detected - Limited support for non-levelling GSI');
                }

                const validLineRatio = analysis.validGSILines / Math.max(1, analysis.totalLines - this.countEmptyLines(analysis));
                
                if (validLineRatio < 0.7) {
                    analysis.errors.push(`‚ùå Poor GSI format: Only ${Math.round(validLineRatio * 100)}% of lines are valid GSI format`);
                }

                if (analysis.validGSILines === 0) {
                    analysis.errors.push('‚ùå No valid GSI data found - Check file format');
                }

                if (analysis.wordCounts['11'] === 0) {
                    analysis.warnings.push('‚ö†Ô∏è No point IDs (WI 11) found');
                }

                if (Object.keys(analysis.wordCounts).length < 3) {
                    analysis.warnings.push('‚ö†Ô∏è Very limited GSI word types detected');
                }
            }

            countEmptyLines(analysis) {
                return analysis.totalLines - analysis.validGSILines - analysis.invalidLines.length;
            }

            displayFormatWarnings(analysis) {
                const messages = [];
                if (analysis.formatType !== 'unknown') {
                    messages.push(`üìã GSI Format: ${analysis.formatType}`);
                }
                if (analysis.isTPS) {
                    messages.push('üî∂ TPS GSI Detected: This file appears to contain Total Station data. This parser is specialised for levelling data and may not display all TPS features correctly.');
                }
                analysis.errors.forEach(error => messages.push(error));
                analysis.warnings.forEach(warning => messages.push(warning));
                if (analysis.invalidLines.length > 0) {
                    const exampleCount = Math.min(3, analysis.invalidLines.length);
                    if (analysis.invalidLines.length > exampleCount) {
                        messages.push(`... and ${analysis.invalidLines.length - exampleCount} more formatting issues`);
                    }
                }
                if (messages.length > 0) {
                    const messageText = messages.join('\n');
                    let messageType = 'success';
                    if (analysis.errors.length > 0) messageType = 'error';
                    else if (analysis.warnings.length > 0 || analysis.isTPS) messageType = 'warning';
                    this.showFormatStatus(messageText, messageType);
                }
            }

            showFormatStatus(message, type) {
                let formatStatus = document.getElementById('formatStatus');
                formatStatus.innerHTML = ''; // Clear previous content, including buttons
                
                const textContainer = document.createElement('div');
                textContainer.innerText = message;
                formatStatus.appendChild(textContainer);
                
                formatStatus.className = 'status ' + type;
                formatStatus.classList.remove('hidden');
                formatStatus.style.whiteSpace = 'pre-line';
                formatStatus.style.marginTop = '10px';
                formatStatus.style.fontSize = '13px';
            }

            updateProcessingOptions(options) {
                this.processingOptions = { ...this.processingOptions, ...options };
                this.processAndAnalyze(); // Re-run the analysis with new options
                return this.data;
            }

            parseLine(line) {
                const words = line.split(/\s+/);
                const record = { words: {}, type: 'unknown' };
                for (const word of words) {
                    const parsed = this.parseWord(word);
                    if (parsed) {
                        record.words[parsed.wi] = parsed;
                    }
                }
                if (record.words['331']) record.type = 'backsight';
                else if (record.words['332']) record.type = 'foresight';
                else if (record.words['333']) record.type = 'intermediate';
                else if (record.words['330']) record.type = 'measure_only';
                return Object.keys(record.words).length > 0 ? record : null;
            }

            parseWord(word) {
                if (word.length < 8 || word.length > 100) return null;
                let wi, info, sign, data;
                if (word.startsWith('*')) {
                    wi = word.substring(1, 3);
                    info = word.substring(3, 7);
                    sign = word.substring(7, 8);
                    data = word.substring(8);
                } else {
                    const first3 = word.substring(0, 3);
                    const fourth = word.substring(3, 4);
                    if (!isNaN(first3) && fourth === '.' && first3.length === 3 && 
                        parseInt(first3) >= 330 && parseInt(first3) <= 399) {
                        wi = first3;
                        info = word.substring(3, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    } else {
                        wi = word.substring(0, 2);
                        info = word.substring(2, 6);
                        sign = word.substring(6, 7);
                        data = word.substring(7);
                    }
                }
                if (wi && isNaN(parseInt(wi))) {
                    console.warn('Non-numeric WI detected:', wi, 'in word:', word.substring(0, 20));
                    return null;
                }
                const value = this.interpretValue(wi, sign + data, info);
                return { wi, info, sign, data, value };
            }

            interpretValue(wi, valueStr, info) {
                if (wi === '11') {
                    let cleaned = valueStr.replace(/^[+\-0]*/, '');
                    cleaned = cleaned.replace(/^0+/, '') || valueStr;
                    if (!cleaned || cleaned.length === 0) {
                        cleaned = valueStr;
                    }
                    return cleaned;
                }
                const num = parseInt(valueStr);
                if (isNaN(num)) {
                    console.warn('Non-numeric value for WI', wi, ':', valueStr);
                    return 0;
                }
                const pos6 = info.charAt(info.length - 1);
                let scale = 1000;
                if (pos6 === '6') scale = 10000;
                else if (pos6 === '8') scale = 100000;
                if (['390', '391', '392'].includes(wi)) return num;
                return num / scale;
            }

            detectMethod() {
                // 1. Check for the explicit method code in the full, original dataset first. This is the most reliable source.
                const methodRecord = this.fullData.find(r => r.words['41'] && r.words['41'].data.includes('?'));
                if (methodRecord) {
                    const code = methodRecord.words['41'].data;
                    if (code.includes('1')) return 'BF';
                    if (code.includes('2')) return 'BFFB';
                    return 'Unknown'; // Code found but not recognized
                }

                // 2. If no code is found, infer from the structure of the main level runs.
                if (!this.levelRuns || this.levelRuns.length === 0) {
                    return '‚Äî'; // Not enough data to make a determination
                }

                // Get an array of foresight counts for each setup that has at least one foresight.
                const foresightCounts = this.levelRuns
                    .map(run => run.foresights.length)
                    .filter(count => count > 0);
                
                if (foresightCounts.length === 0) {
                    return '‚Äî'; // No complete setups found in the main run
                }

                // Check for consistent patterns
                const allAreBF = foresightCounts.every(count => count === 1);
                if (allAreBF) {
                    return 'BF (Inferred)';
                }

                const allAreBFFB = foresightCounts.every(count => count === 2);
                if (allAreBFFB) {
                    return 'BFFB (Inferred)';
                }

                return 'Mixed/Unknown'; // If patterns are inconsistent, we can't be sure
            }

            identifyCalibrationData(runsForDetection) {
                const result = { isCalibration: false, type: null, confidence: 0, issues: [], recordRange: null };
                const points = new Set();
                this.fullData.forEach(record => {
                    if (record.words['11']) points.add(record.words['11'].value);
                });
                const uniquePoints = Array.from(points);

                // Check for 2-peg test at start of file (first 10 records)
                const earlyRecords = this.fullData.slice(0, 10);
                const early2PegCheck = this.checkEarly2PegPattern(earlyRecords);
                if (early2PegCheck.is2Peg) {
                    result.isCalibration = true;
                    result.type = '2-peg-test';
                    result.confidence = early2PegCheck.confidence;
                    result.issues = early2PegCheck.issues;
                    result.recordRange = early2PegCheck.recordRange;
                    return result;
                }
                
                // Fallback for smaller datasets or different naming
                if (runsForDetection.length > 5 || uniquePoints.length > 8) {
                    return result;
                }
                
                let confidenceScore = 0;
                const maxConfidence = 100;
                
                const calibrationNames = uniquePoints.filter(point => 
                    /^(PEG|PG|A|B|TEST|CAL|CALIB|CALIBR|2PEG|TWOPEG|TP1|TP2)$/i.test(point) ||
                    /^[AB][12]?$/i.test(point) ||
                    /^(POINT|PT)[AB12]?$/i.test(point)
                );
                
                if (calibrationNames.length >= 2) {
                    confidenceScore += 30;
                    result.issues.push(`Calibration-style point names detected: ${calibrationNames.join(', ')}`);
                }
                if (uniquePoints.length === 2 && runsForDetection.length >= 2 && runsForDetection.length <= 3) {
                    confidenceScore += 25;
                    result.issues.push('Classic 2-peg test pattern: 2 points with 2-3 setups');
                }
                const repeatedPattern = this.checkRepeatedPointPattern(runsForDetection);
                if (repeatedPattern.hasRepeated) {
                    confidenceScore += 20;
                    result.issues.push(`Points observed multiple times: ${repeatedPattern.repeatedPoints.join(', ')}`);
                }
                const distanceCheck = this.checkDistancePattern();
                if (distanceCheck.isTypical2PegDistance) {
                    confidenceScore += 15;
                    result.issues.push(`Distance pattern consistent with 2-peg test: ~${distanceCheck.distance.toFixed(0)}m`);
                }
                if (this.fullData.length <= 10 && uniquePoints.length <= 4) {
                    confidenceScore += 10;
                    result.issues.push('Very limited data set typical of calibration test');
                }
                
                if (confidenceScore >= 40) {
                    result.isCalibration = true;
                    result.type = confidenceScore >= 60 ? '2-peg-test' : 'possible-calibration';
                    result.confidence = Math.min(confidenceScore, maxConfidence);
                    if (!result.recordRange && runsForDetection.length > 0) {
                        const firstLine = runsForDetection[0].backsight.lineNumber;
                        const lastRun = runsForDetection[runsForDetection.length-1];
                        const lastLine = lastRun.foresights.length > 0 ? lastRun.foresights.slice(-1)[0].lineNumber : lastRun.backsight.lineNumber;
                        result.recordRange = `Lines ${firstLine} to ${lastLine}`;
                    }
                }
                
                return result;
            }

            checkEarly2PegPattern(earlyRecords) {
                const result = { is2Peg: false, confidence: 0, issues: [], recordRange: null };
                const pointPattern = [];
                const recordNumbers = [];
                
                earlyRecords.forEach(record => {
                    const pointName = record.words['11']?.value;
                    if (pointName && /^[AB][12]$/i.test(pointName)) {
                        pointPattern.push(pointName.toUpperCase());
                        recordNumbers.push(record.lineNumber);
                    }
                });
                
                const patternStr = pointPattern.join('-');
                const classic2PegPatterns = ['A1-B1-B2-A2', 'A1-B1-A2-B2', 'B1-A1-A2-B2', 'B1-A1-B2-A2'];
                
                if (classic2PegPatterns.includes(patternStr) && recordNumbers.length > 0) {
                    result.is2Peg = true;
                    result.confidence = 95;
                    result.recordRange = `Records ${recordNumbers[0]} to ${recordNumbers[recordNumbers.length - 1]}`;
                    result.issues.push(`Classic 2-peg test sequence detected: ${patternStr}`);
                    result.issues.push('This calibration data may affect survey calculations if included.');
                    return result;
                }
                
                if (pointPattern.length >= 2) {
                    const hasAB = pointPattern.some(p => p.startsWith('A')) && pointPattern.some(p => p.startsWith('B'));
                    if (hasAB && recordNumbers.length > 0 && recordNumbers[recordNumbers.length - 1] <= 6) {
                        result.is2Peg = true;
                        result.confidence = 75;
                        result.recordRange = `Records ${recordNumbers[0]} to ${recordNumbers[recordNumbers.length - 1]}`;
                        result.issues.push('Early A/B point sequence suggests calibration test.');
                    }
                }
                
                return result;
            }

            checkRepeatedPointPattern(runsForDetection) {
                const pointObservations = {};
                const result = { hasRepeated: false, repeatedPoints: [] };
                
                runsForDetection.forEach(run => {
                    const bsPoint = run.backsight.words['11']?.value;
                    if (bsPoint) pointObservations[bsPoint] = (pointObservations[bsPoint] || 0) + 1;
                    run.foresights.forEach(fs => {
                        const fsPoint = fs.words['11']?.value;
                        if (fsPoint) pointObservations[fsPoint] = (pointObservations[fsPoint] || 0) + 1;
                    });
                });
                
                Object.entries(pointObservations).forEach(([point, count]) => {
                    if (count > 2) {
                        result.hasRepeated = true;
                        result.repeatedPoints.push(`${point}(${count}x)`);
                    }
                });
                
                return result;
            }

            checkDistancePattern() {
                const result = { isTypical2PegDistance: false, distance: 0 };
                const coordinatePoints = this.fullData.filter(record => 
                    record.words['11'] && record.words['81'] && record.words['82']
                ).map(record => ({ name: record.words['11'].value, x: record.words['81'].value, y: record.words['82'].value }));
                
                if (coordinatePoints.length >= 2) {
                    const p1 = coordinatePoints[0];
                    const p2 = coordinatePoints[1];
                    const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    result.distance = distance;
                    if (distance >= 40 && distance <= 80) result.isTypical2PegDistance = true;
                }
                return result;
            }

            displayCalibrationWarning(calibrationInfo) {
                const messages = [];
                messages.push(`üî∂ ${calibrationInfo.type.toUpperCase()} DETECTED (${calibrationInfo.confidence}% confidence)`);
                if (calibrationInfo.recordRange) {
                    messages.push(`üìç Located in ${calibrationInfo.recordRange}. These records will be excluded by default.`);
                }
                messages.push('\nIssues found:');
                calibrationInfo.issues.forEach(issue => {
                    messages.push(`‚Ä¢ ${issue}`);
                });
                
                const messageText = messages.join('\n');
                this.showFormatStatus(messageText, 'warning');

                const formatStatusEl = document.getElementById('formatStatus');
                
                // Remove any old buttons first
                const oldActions = formatStatusEl.querySelector('#calibration-actions');
                if(oldActions) oldActions.remove();

                const actionsContainer = document.createElement('div');
                actionsContainer.style.marginTop = '10px';
                actionsContainer.id = 'calibration-actions';

                const showCalibBtn = document.createElement('button');
                showCalibBtn.textContent = 'üîç View Calibration Test Only';
                showCalibBtn.className = 'btn status-action';
                showCalibBtn.onclick = () => showCalibrationOnly(); 
                
                const showMainBtn = document.createElement('button');
                showMainBtn.textContent = 'üìã View Main Survey Only';
                showMainBtn.className = 'btn status-action';
                showMainBtn.onclick = () => showMainSurveyOnly();

                actionsContainer.appendChild(showCalibBtn);
                actionsContainer.appendChild(showMainBtn);
                formatStatusEl.appendChild(actionsContainer);
            }

            buildLevelRuns(dataToProcess) {
                const runs = [];
                let currentRun = null;
                let setupNumber = 0;
                
                dataToProcess.forEach(record => {
                    if (record.type === 'backsight') {
                        if (currentRun) runs.push(currentRun);
                        setupNumber++;
                        currentRun = {
                            setupNumber: setupNumber,
                            backsight: record,
                            foresights: [],
                            intermediates: []
                        };
                        record.setupNumber = setupNumber;
                    } else if (currentRun) {
                        record.setupNumber = setupNumber;
                        if (record.type === 'foresight') currentRun.foresights.push(record);
                        else if (record.type === 'intermediate') currentRun.intermediates.push(record);
                    }
                });
                if (currentRun) runs.push(currentRun);
                
                runs.forEach((run, index) => {
                    const newSetupNum = index + 1;
                    run.setupNumber = newSetupNum;
                    run.backsight.setupNumber = newSetupNum;
                    run.foresights.forEach(r => r.setupNumber = newSetupNum);
                    run.intermediates.forEach(r => r.setupNumber = newSetupNum);
                });
                
                return runs;
            }

            isChangePoint(pointId) {
                if (!pointId) return false;
                const method = this.processingOptions.changePointMethod;
                const prefix = this.processingOptions.changePointPrefix.toUpperCase();
                const upperPointId = pointId.toUpperCase();
                
                switch (method) {
                    case 'prefix': return upperPointId.startsWith(prefix);
                    case 'numeric':
                        if (!/^\d+$/.test(pointId)) return false;
                        const num = parseInt(pointId);
                        return num >= this.processingOptions.numericMin && num <= this.processingOptions.numericMax;
                    case 'both':
                        if (upperPointId.startsWith(prefix)) return true;
                        if (!/^\d+$/.test(pointId)) return false;
                        const numBoth = parseInt(pointId);
                        return numBoth >= this.processingOptions.numericMin && numBoth <= this.processingOptions.numericMax;
                    default: return false;
                }
            }
            
            aggregateChangePointRuns() {
                const runsToProcess = this.levelRuns; // Use the main survey runs
                if (!this.processingOptions.aggregateCP) return runsToProcess;
                const aggregatedRuns = [];
                let i = 0;
                while (i < runsToProcess.length) {
                    const currentRun = runsToProcess[i];
                    const bsPoint = currentRun.backsight.words['11']?.value || '';
                    const isStartOfSequence = !this.isChangePoint(bsPoint) && 
                        currentRun.foresights.some(fs => this.isChangePoint(fs.words['11']?.value || ''));
                    
                    if (!isStartOfSequence) {
                        aggregatedRuns.push(currentRun);
                        i++;
                        continue;
                    }
                    
                    let sequenceRuns = [currentRun];
                    let j = i + 1;
                    while (j < runsToProcess.length) {
                        const nextRun = runsToProcess[j];
                        const nextBsPoint = nextRun.backsight.words['11']?.value || '';
                        if (this.isChangePoint(nextBsPoint)) {
                            sequenceRuns.push(nextRun);
                            j++;
                        } else break;
                    }
                    
                    const firstRun = sequenceRuns[0];
                    const lastRun = sequenceRuns[sequenceRuns.length - 1];
                    const finalForesight = lastRun.foresights.find(fs => !this.isChangePoint(fs.words['11']?.value || ''));
                    
                    if (finalForesight) {
                        let totalDistance = 0, totalHeightDiff = 0;
                        sequenceRuns.forEach(run => {
                            const bsReading = run.backsight.words['331']?.value || 0;
                            totalDistance += run.backsight.words['32']?.value || 0;
                            run.foresights.forEach(fs => {
                                totalDistance += fs.words['32']?.value || 0;
                                totalHeightDiff += (bsReading - (fs.words['332']?.value || 0));
                            });
                        });
                        
                        aggregatedRuns.push({
                            setupNumber: firstRun.setupNumber,
                            backsight: firstRun.backsight,
                            foresights: [finalForesight],
                            intermediates: [],
                            totalTurns: sequenceRuns.length,
                            totalDistance: totalDistance,
                            totalHeightDiff: totalHeightDiff,
                            isAggregated: true,
                            changePoints: sequenceRuns.slice(0, -1).map(r => r.foresights).flat().filter(fs => this.isChangePoint(fs.words['11']?.value || ''))
                        });
                    } else {
                        aggregatedRuns.push(...sequenceRuns);
                    }
                    i = j;
                }
                return aggregatedRuns;
            }

            generateReport() {
                let report = 'LEVELLING REPORT\n================\n\n';

                if (this.calibrationInfo.isCalibration && !this.processingOptions.retainCalibrationData) {
                    report += `NOTE: A ${this.calibrationInfo.type} was detected and excluded from this analysis.\n`;
                    report += `Original file had ${this.fullData.length} records. Processing ${this.data.length} main survey records.\n\n`;
                }
                
                report += `Generated: ${new Date().toLocaleString()}\n`;
                report += `Records Shown: ${this.stats.recordCount}\n`;
                report += `Unique Points: ${this.stats.pointCount}\n`;
                report += `Setups: ${this.stats.setupCount}\n`;
                report += `Method: ${this.stats.method}\n`;
                report += `Height Range: ${this.stats.heightRange}\n`;
                
                if (this.processingOptions.aggregateCP) {
                    let cpInfo = 'Change Point Processing: Enabled (';
                    const { changePointMethod, changePointPrefix, numericMin, numericMax } = this.processingOptions;
                    if (changePointMethod === 'prefix') cpInfo += `Prefix: ${changePointPrefix}`;
                    else if (changePointMethod === 'numeric') cpInfo += `Numeric: ${numericMin}-${numericMax}`;
                    else cpInfo += `Both: ${changePointPrefix} and ${numericMin}-${numericMax}`;
                    cpInfo += ')\n';
                    report += cpInfo;
                }
                
                report += '\nPOINT          TYPE          READING       DISTANCE      HEIGHT        SETUP\n';
                report += '-----------------------------------------------------------------------\n';
                
                this.data.forEach(record => {
                    const point = record.words['11']?.value || '';
                    const dist = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                    const hgt = record.words['83'] ? record.words['83'].value.toFixed(4) : '';
                    const setup = record.setupNumber || '';
                    let reading = ['331', '332', '333', '330'].map(wi => record.words[wi] ? record.words[wi].value.toFixed(5) : null).find(Boolean) || '';
                    report += `${point.padEnd(14)} ${record.type.padEnd(13)} ${reading.padStart(13)} ${dist.padStart(13)} ${hgt.padStart(13)} ${String(setup).padStart(5)}\n`;
                });
                
                if (this.levelRuns && this.levelRuns.length > 0) {
                    report += '\nLEVEL RUN SUMMARY\n==================\n\n';
                    const runsToShow = this.processingOptions.aggregateCP ? this.aggregatedRuns : this.levelRuns;
                    
                    runsToShow.forEach(run => {
                        const bsPoint = run.backsight.words['11']?.value || '';
                        const bsReading = (run.backsight.words['331']?.value || 0).toFixed(5);
                        const bsDist = (run.backsight.words['32']?.value || 0).toFixed(3);
                        report += `Setup ${run.setupNumber}:\n  BS: ${bsPoint.padEnd(10)} (${bsReading}m @ ${bsDist}m)\n`;

                        if (this.processingOptions.showCPDetails && run.changePoints?.length > 0) {
                            run.changePoints.forEach(cp => {
                                const cpPoint = cp.words['11']?.value || '';
                                const cpReading = (cp.words['332']?.value || 0).toFixed(5);
                                const cpDist = (cp.words['32']?.value || 0).toFixed(3);
                                report += `  CP: ${cpPoint.padEnd(10)} (${cpReading}m @ ${cpDist}m)\n`;
                            });
                        }
                        
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11']?.value || '';
                            const fsReading = (fs.words['332']?.value || 0).toFixed(5);
                            const fsDist = (fs.words['32']?.value || 0).toFixed(3);
                            const heightDiff = run.isAggregated 
                                ? run.totalHeightDiff.toFixed(5) 
                                : ((run.backsight.words['331']?.value || 0) - (fs.words['332']?.value || 0)).toFixed(5);
                            
                            let fsLine = `  FS: ${fsPoint.padEnd(10)} (${fsReading}m @ ${fsDist}m) Œîh=${heightDiff} m`;
                            if (this.processingOptions.includeTurnCount && run.isAggregated && run.totalTurns > 1) {
                                fsLine += ` [${run.totalTurns} turns]`;
                            }
                            report += fsLine + '\n';
                        });
                        
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11']?.value || '';
                            const isReading = (is.words['333']?.value || 0).toFixed(5);
                            const isDist = (is.words['32']?.value || 0).toFixed(3);
                            report += `  IS: ${isPoint.padEnd(10)} (${isReading}m @ ${isDist}m)\n`;
                        });
                        report += '\n';
                    });
                }
                return report;
            }

            exportStarNet() {
                let output = '# GSI Level Data Export\n';
                output += `# Generated: ${new Date().toLocaleString()}\n`;
                output += `# Method: ${this.stats.method}\n`;
                output += `# Setups: ${this.stats.setupCount}\n\n`;
                
                output += '.UNITS METERS\n';
                output += '#.SEPARATOR /\n\n';

                if (this.calibrationInfo.isCalibration && !this.processingOptions.retainCalibrationData) {
                    output += `# NOTE: A ${this.calibrationInfo.type} was detected at the beginning of the file and has been excluded from this export.\n\n`;
                }
                
                const firstPoint = this.data.find(r => r.words['11'] && r.words['83']);
                if (firstPoint) {
                    output += '# Fixed elevation - uncomment if needed:\n';
                    output += `#E ${firstPoint.words['11'].value} ${firstPoint.words['83'].value.toFixed(4)}\n\n`;
                }
                
                const runsToProcess = this.processingOptions.aggregateCP ? this.aggregatedRuns : this.levelRuns;
                
                if (runsToProcess && runsToProcess.length > 0) {
                    runsToProcess.forEach(run => {
                        const bsPoint = run.backsight.words['11'] ? run.backsight.words['11'].value : '';
                        const bsReading = run.backsight.words['331'] ? run.backsight.words['331'].value : 0;
                        const bsDistance = run.backsight.words['32'] ? run.backsight.words['32'].value : 0;
                        
                        run.foresights.forEach(fs => {
                            const fsPoint = fs.words['11'] ? fs.words['11'].value : '';
                            const fsReading = fs.words['332'] ? fs.words['332'].value : 0;
                            const fsDistance = fs.words['32'] ? fs.words['32'].value : 0;
                            
                            if (bsPoint && fsPoint) {
                                let heightDiff, totalDistance;
                                let comment = '';
                                
                                if (run.isAggregated) {
                                    heightDiff = run.totalHeightDiff;
                                    totalDistance = run.totalDistance;
                                    comment = `# Setup ${run.setupNumber}: Aggregated ${run.totalTurns} turns, Total distance=${totalDistance.toFixed(3)}m`;
                                } else {
                                    heightDiff = bsReading - fsReading;
                                    totalDistance = bsDistance + fsDistance;
                                    comment = `# Setup ${run.setupNumber}: BS=${bsDistance.toFixed(3)}m, FS=${fsDistance.toFixed(3)}m`;
                                }
                                
                                output += comment + '\n';
                                output += `L ${bsPoint}-${fsPoint} ${heightDiff.toFixed(5)} ${totalDistance.toFixed(3)}\n\n`;
                            }
                        });
                        
                        run.intermediates.forEach(is => {
                            const isPoint = is.words['11'] ? is.words['11'].value : '';
                            const isHeight = is.words['83'] ? is.words['83'].value : null;
                            
                            if (isPoint && isHeight !== null) {
                                output += '# Intermediate sight - uncomment if needed:\n';
                                output += `#E ${isPoint} ${isHeight.toFixed(4)}\n\n`;
                            }
                        });
                    });
                }
                
                output += '# End of level data\n';
                return output;
            }

            exportCSV() {
                let csv = 'Point,Type,Reading,Distance,Height,Setup,Line\n';
                this.data.forEach(record => {
                    const point = record.words['11']?.value || '';
                    const dist = record.words['32']?.value || '';
                    const hgt = record.words['83']?.value || '';
                    const setup = record.setupNumber || '';
                    let reading = ['331', '332', '333', '330'].map(wi => record.words[wi]?.value).find(Boolean) || '';
                    csv += `"${point}","${record.type}","${reading}","${dist}","${hgt}","${setup}","${record.lineNumber}"\n`;
                });
                return csv;
            }
        }

        // --- Global App State & Functions ---
        
        let parser; // Will be initialized on file load
        let currentOutput = '';
        let currentFilename = 'export';
        let currentExtension = 'txt';
        let isFullView = false;

        const elements = {
            themeBtn: document.getElementById('themeBtn'),
            uploadArea: document.getElementById('uploadArea'),
            fileInput: document.getElementById('fileInput'),
            status: document.getElementById('status'),
            formatStatus: document.getElementById('formatStatus'),
            statsSection: document.getElementById('statsSection'),
            actionsSection: document.getElementById('actionsSection'),
            previewSection: document.getElementById('previewSection'),
            outputSection: document.getElementById('outputSection'),
            dataTable: document.getElementById('dataTable'),
            outputArea: document.getElementById('outputArea'),
            recordCount: document.getElementById('recordCount'),
            pointCount: document.getElementById('pointCount'),
            methodType: document.getElementById('methodType'),
            heightRange: document.getElementById('heightRange'),
            reportBtn: document.getElementById('reportBtn'),
            starnetBtn: document.getElementById('starnetBtn'),
            csvBtn: document.getElementById('csvBtn'),
            advancedBtn: document.getElementById('advancedBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            copyBtn: document.getElementById('copyBtn'),
            advancedSection: document.getElementById('advancedSection'),
            advancedToggle: document.getElementById('advancedToggle'),
            applyAdvanced: document.getElementById('applyAdvanced'),
            aggregateCP: document.getElementById('aggregateCP'),
            changePointPrefix: document.getElementById('changePointPrefix'),
            includeTurnCount: document.getElementById('includeTurnCount'),
            showCPDetails: document.getElementById('showCPDetails'),
            retainCalibration: document.getElementById('retainCalibration'),
            prefixSettings: document.getElementById('prefixSettings'),
            numericSettings: document.getElementById('numericSettings'),
            numericMin: document.getElementById('numericMin'),
            numericMax: document.getElementById('numericMax'),
            applyText: document.getElementById('applyText'),
            applySpinner: document.getElementById('applySpinner'),
            aboutBtn: document.getElementById('aboutBtn'),
            aboutSection: document.getElementById('aboutSection'),
            aboutToggle: document.getElementById('aboutToggle'),
            toggleViewBtn: document.getElementById('toggleViewBtn')
        };

        function initializeApp() {
            setupEventListeners();
            loadSavedTheme();
        }

        function setupEventListeners() {
            elements.themeBtn.addEventListener('click', toggleTheme);
            elements.uploadArea.addEventListener('click', () => elements.fileInput.click());
            elements.uploadArea.addEventListener('dragover', handleDragOver);
            elements.uploadArea.addEventListener('dragleave', handleDragLeave);
            elements.uploadArea.addEventListener('drop', handleDrop);
            elements.fileInput.addEventListener('change', handleFileSelect);
            elements.advancedBtn.addEventListener('click', toggleAdvancedSection);
            elements.advancedToggle.addEventListener('click', hideAdvancedSection);
            elements.aboutBtn.addEventListener('click', toggleAboutSection);
            elements.aboutToggle.addEventListener('click', hideAboutSection);
            document.querySelectorAll('input[name="changePointMethod"]').forEach(radio => {
                radio.addEventListener('change', (e) => toggleChangePointSettings(e.target.value));
            });
            elements.applyAdvanced.addEventListener('click', applyAdvancedSettings);
            elements.reportBtn.addEventListener('click', () => {
                setActiveExportButton('reportBtn');
                currentExtension = 'txt';
                showOutput(parser.generateReport(), 'Report');
            });
            elements.starnetBtn.addEventListener('click', () => {
                setActiveExportButton('starnetBtn');
                currentExtension = 'dat';
                showOutput(parser.exportStarNet(), 'StarNet DAT');
            });
            elements.csvBtn.addEventListener('click', () => {
                setActiveExportButton('csvBtn');
                currentExtension = 'csv';
                showOutput(parser.exportCSV(), 'CSV');
            });
            elements.downloadBtn.addEventListener('click', downloadOutput);
            elements.copyBtn.addEventListener('click', copyOutput);
            elements.toggleViewBtn.addEventListener('click', () => {
                isFullView = !isFullView;
                updateUI();
            });
            elements.uploadArea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    elements.fileInput.click();
                }
            });
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            const newTheme = current === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', newTheme);
            try { localStorage.setItem('theme', newTheme); } catch(e) {}
        }

        function loadSavedTheme() {
            try {
                const savedTheme = localStorage.getItem('theme') || 'dark';
                document.documentElement.setAttribute('data-theme', savedTheme);
            } catch (e) {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        }

        function handleDragOver(e) { e.preventDefault(); elements.uploadArea.classList.add('dragover'); }
        function handleDragLeave(e) { elements.uploadArea.classList.remove('dragover'); }
        
        function handleDrop(e) {
            e.preventDefault();
            elements.uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) processFile(e.dataTransfer.files[0]);
        }

        function handleFileSelect(e) {
            if (e.target.files.length > 0) processFile(e.target.files[0]);
        }

        function toggleAdvancedSection() {
            elements.advancedSection.classList.toggle('hidden');
            elements.advancedBtn.textContent = elements.advancedSection.classList.contains('hidden') ? '‚öôÔ∏è Advanced' : '‚öôÔ∏è Hide Advanced';
        }
        function hideAdvancedSection() {
            elements.advancedSection.classList.add('hidden');
            elements.advancedBtn.textContent = '‚öôÔ∏è Advanced';
        }
        function toggleAboutSection() {
            elements.aboutSection.classList.toggle('hidden');
            elements.aboutBtn.textContent = elements.aboutSection.classList.contains('hidden') ? '‚ÑπÔ∏è About' : '‚ÑπÔ∏è Hide About';
        }
        function hideAboutSection() {
            elements.aboutSection.classList.add('hidden');
            elements.aboutBtn.textContent = '‚ÑπÔ∏è About';
        }

        function setActiveExportButton(activeButtonId) {
            ['reportBtn', 'starnetBtn', 'csvBtn'].forEach(id => elements[id].classList.remove('primary'));
            elements[activeButtonId].classList.add('primary');
        }

        function toggleChangePointSettings(method) {
            elements.prefixSettings.style.display = (method === 'prefix' || method === 'both') ? 'block' : 'none';
            elements.numericSettings.style.display = (method === 'numeric' || method === 'both') ? 'block' : 'none';
        }

        async function applyAdvancedSettings() {
            const button = elements.applyAdvanced;
            const originalText = elements.applyText.textContent;
            button.disabled = true;
            elements.applyText.style.display = 'none';
            elements.applySpinner.style.display = 'inline-block';
            
            try {
                const newOptions = {
                    aggregateCP: elements.aggregateCP.checked,
                    changePointPrefix: elements.changePointPrefix.value || 'CP',
                    changePointMethod: document.querySelector('input[name="changePointMethod"]:checked').value,
                    numericMin: parseInt(elements.numericMin.value) || 1,
                    numericMax: parseInt(elements.numericMax.value) || 999,
                    includeTurnCount: elements.includeTurnCount.checked,
                    showCPDetails: elements.showCPDetails.checked,
                    retainCalibrationData: elements.retainCalibration.checked
                };
                
                await new Promise(resolve => setTimeout(resolve, 300));
                
                parser.updateProcessingOptions(newOptions);
                updateUI();
                elements.outputSection.classList.add('hidden'); // Hide old output
                
                elements.applyText.textContent = '‚úì Applied';
                button.style.background = 'var(--accent)';
                button.style.color = 'var(--bg)';
            } catch (error) {
                console.error('Reprocessing error:', error);
                showStatus(`‚úó Error reprocessing: ${error.message}`, 'error');
            } finally {
                elements.applySpinner.style.display = 'none';
                elements.applyText.style.display = 'inline';
                button.disabled = false;
                setTimeout(() => {
                    elements.applyText.textContent = originalText;
                    button.style.background = '';
                    button.style.color = '';
                }, 2000);
            }
        }

        function processFile(file) {
            resetUI();
            showStatus('Processing...', 'info');
            currentFilename = file.name.replace(/\.[^/.]+$/, ""); 

            const reader = new FileReader();
            reader.onload = e => {
                const timeoutId = setTimeout(() => {
                    showStatus('‚úó Processing timed out. The file might be too large or malformed.', 'error');
                }, PROCESSING_TIMEOUT);

                try {
                    parser = new GSIParser();
                    parser.parse(e.target.result);
                    
                    if (parser.data.length === 0 && !parser.calibrationInfo.isCalibration) {
                         showStatus('‚úó No valid survey data found to process.', 'error');
                         resetUI();
                    } else {
                        updateUI();
                        elements.reportBtn.click(); // Auto-generate and show the report
                    }
                } catch (error) {
                    showStatus(`‚úó Error: ${escapeHtml(error.message)}`, 'error');
                    console.error('Parsing error:', error);
                    resetUI();
                } finally {
                    clearTimeout(timeoutId);
                }
            };
            
            reader.onerror = () => {
                showStatus('‚úó Error reading file.', 'error');
                resetUI();
            };
            
            reader.readAsText(file);
        }
        
        function resetUI() {
            ['status', 'formatStatus', 'statsSection', 'actionsSection', 'previewSection', 'outputSection', 'advancedSection'].forEach(id => elements[id].classList.add('hidden'));
            elements.dataTable.innerHTML = '';
            elements.fileInput.value = ''; // Reset file input
            isFullView = false; // Reset view toggle
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showStatus(message, type) {
            elements.status.innerHTML = message; // Use innerHTML to allow line breaks
            elements.status.className = 'status ' + type;
            elements.status.classList.remove('hidden');
        }

        function updateUI() {
            // Update stats
            elements.recordCount.textContent = parser.stats.recordCount;
            elements.pointCount.textContent = parser.stats.pointCount;
            elements.methodType.textContent = parser.stats.method;
            elements.heightRange.textContent = parser.stats.heightRange;

            // Update toggle button visibility and text
            if (parser.data.length > 20) {
                elements.toggleViewBtn.style.display = 'inline-block';
                let fullViewText = parser.data.length > MAX_PREVIEW_ROWS ? `first ${MAX_PREVIEW_ROWS}` : parser.data.length;
                elements.toggleViewBtn.textContent = isFullView ? 'Show Preview (20)' : `Show All (${fullViewText}) Rows`;
            } else {
                elements.toggleViewBtn.style.display = 'none';
            }

            // Determine which data to display
            const dataToDisplay = isFullView ? parser.data.slice(0, MAX_PREVIEW_ROWS) : parser.data.slice(0, 20);

            // Update table
            elements.dataTable.innerHTML = '';
            if (dataToDisplay.length === 0) {
                const row = elements.dataTable.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 6;
                cell.textContent = "No data to display in this view.";
                cell.style.textAlign = 'center';
            } else {
                dataToDisplay.forEach(function(record) {
                    const row = document.createElement('tr');
                    const point = record.words['11']?.value || '';
                    const type = record.type;
                    const reading = ['331', '332', '333', '330'].map(wi => record.words[wi]?.value.toFixed(5)).find(Boolean) || '';
                    const distance = record.words['32'] ? record.words['32'].value.toFixed(3) : '';
                    const height = record.words['83'] ? record.words['83'].value.toFixed(4) : '';
                    const setup = record.setupNumber || '';

                    row.innerHTML = `
                        <td>${escapeHtml(point)}</td>
                        <td><span class="type-badge type-${escapeHtml(type)}">${escapeHtml(type)}</span></td>
                        <td>${escapeHtml(reading)}</td>
                        <td>${escapeHtml(distance)}</td>
                        <td>${escapeHtml(height)}</td>
                        <td>${escapeHtml(String(setup))}</td>
                    `;
                    elements.dataTable.appendChild(row);
                });
            }

            // Show sections
            elements.statsSection.classList.remove('hidden');
            elements.actionsSection.classList.remove('hidden');
            elements.previewSection.classList.remove('hidden');
        }

        function showCalibrationOnly() {
            if (!parser || !parser.calibrationInfo.isCalibration) return;
            
            const endLineMatch = parser.calibrationInfo.recordRange.match(/to\s(\d+)/);
            const startLineMatch = parser.calibrationInfo.recordRange.match(/from\s(\d+)|Records\s(\d+)/i);
            const startLine = startLineMatch ? parseInt(startLineMatch[1] || startLineMatch[2]) : 1;

            if (endLineMatch) {
                const endLine = parseInt(endLineMatch[1]);
                
                parser.data = parser.fullData.filter(rec => rec.lineNumber >= startLine && rec.lineNumber <= endLine);
                
                parser.calculateStatsForCurrentData();
                updateUI();
                
                showStatus(`Displaying ${parser.data.length} calibration records only.`, 'info');
                
                const formatStatusEl = document.getElementById('formatStatus');
                const actionsContainer = formatStatusEl.querySelector('#calibration-actions');
                if (actionsContainer) {
                    actionsContainer.innerHTML = ''; // Clear old buttons
                    const showMainBtn = document.createElement('button');
                    showMainBtn.textContent = 'üìã View Main Survey';
                    showMainBtn.className = 'btn status-action';
                    showMainBtn.onclick = () => showMainSurveyOnly();
                    actionsContainer.appendChild(showMainBtn);
                }
                
                elements.outputSection.classList.add('hidden');
                elements.reportBtn.click();
            }
        }

        function showMainSurveyOnly() {
            if (!parser) return;
            // Re-run the analysis, which defaults to showing the main survey
            parser.processAndAnalyze();
            updateUI();
            elements.outputSection.classList.add('hidden');
            elements.reportBtn.click();
        }

        function showOutput(content, formatName) {
            currentOutput = content;
            elements.outputArea.textContent = content;
            elements.outputSection.classList.remove('hidden');
            elements.downloadBtn.textContent = `üíæ Download ${formatName}`;
        }

        async function downloadOutput() {
            if (!currentOutput) return;
            try {
                const blob = new Blob([currentOutput], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${currentFilename}_${currentExtension}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                const originalText = elements.downloadBtn.textContent;
                elements.downloadBtn.textContent = '‚úì Downloaded';
                setTimeout(() => { elements.downloadBtn.textContent = originalText; }, 2000);
            } catch (error) {
                console.error('Download error:', error);
                showStatus('‚úó Download failed', 'error');
            }
        }

        async function copyOutput() {
            if (!currentOutput) return;
            try {
                await navigator.clipboard.writeText(currentOutput);
                const originalText = elements.copyBtn.textContent;
                elements.copyBtn.textContent = '‚úì Copied';
                setTimeout(() => { elements.copyBtn.textContent = originalText; }, 2000);
            } catch (err) {
                console.error('Failed to copy: ', err);
                showStatus('‚úó Copy failed', 'error');
            }
        }

        window.addEventListener('unhandledrejection', event => {
            console.error('Unhandled promise rejection:', event.reason);
            showStatus('‚úó An unexpected error occurred.', 'error');
        });
        window.addEventListener('error', event => {
            console.error('Global error:', event.error);
            showStatus('‚úó An unexpected error occurred.', 'error');
        });

        // Initialize the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }

    </script>
</body>
</html>